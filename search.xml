<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>c++函数返回多值</title>
      <link href="/2022/12/12/c-han-shu-fan-hui-duo-zhi-zong-jie/"/>
      <url>/2022/12/12/c-han-shu-fan-hui-duo-zhi-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>用惯了Python，才发现c++函数默认是返回一个值/无返回值…<br>但是这怎么能难道聪明的工程师们，下面总结几个c++常用的返回多值办法，std::pair在此不讨论，因为他只能返回两个值…</p><p><a href="https://blog.csdn.net/qq_43685921/article/details/123854007">C++函数返回多个值：结构体、tuple</a></p><h3 id="使用tuple返回多个值"><a href="#使用tuple返回多个值" class="headerlink" title="使用tuple返回多个值"></a>使用tuple返回多个值</h3><p>相比于结构体，要实现函数返回多个值的方法，使用tuple更为简洁、灵活。<br>实现步骤：<br>1.定义函数f(x):类型为tuple<br>2.函数返回多个值:使用make_tuple(result1,result2,…)<br>3.使用函数结果：result=f(x)<br>4.取函数返回值：result1=get&lt;0&gt;(result)； result2=get&lt;1&gt;(result);</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">tuple&lt;<span class="type">int</span>, <span class="type">float</span>&gt;  <span class="title">filterFloorPoint</span><span class="params">( <span class="type">int</span> max_iterations,<span class="type">float</span> in_floor_max_angle,<span class="type">float</span> Distance_Threshold)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> result_iterations;</span><br><span class="line">    <span class="type">float</span> result_angle_add_distance;</span><br><span class="line">    result_iterations=max_iterations*<span class="number">100</span>;</span><br><span class="line">    result_angle_add_distance=in_floor_max_angle*Distance_Threshold;</span><br><span class="line">    <span class="comment">//此时，我们想要函数返回result_iterations和result_angle_add_distance两个值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用make_tuple将要返回的数据写在()里面即可，注意数据类型的顺序</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_tuple</span>(result_iterations,result_angle_add_distance); </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">int</span> max_iterations=<span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> in_floor_max_angle=<span class="number">10.0</span>;</span><br><span class="line"><span class="type">float</span> Distance_Threshold=<span class="number">10.0</span>;</span><br><span class="line"></span><br><span class="line">tuple&lt;<span class="type">int</span>, <span class="type">float</span>&gt;  get_filterFloorPoint_result;</span><br><span class="line"> <span class="comment">//调用 filterFloorPoint 方法</span></span><br><span class="line">get_filterFloorPoint_result=<span class="built_in">filterFloorPoint</span>(max_iterations,in_floor_max_angle,Distance_Threshold);</span><br><span class="line">without_floor_cloud_ptr=<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(get_filterFloorPoint_result); <span class="comment">//取第一个值</span></span><br><span class="line">only_floor_cloud_ptr=<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(get_filterFloorPoint_result);  <span class="comment">//取第二个值</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="使用结构体返回多个值"><a href="#使用结构体返回多个值" class="headerlink" title="使用结构体返回多个值"></a>使用结构体返回多个值</h3><p>实现步骤：<br>1.先定义一个结构体<br>2.准备我们要实现的函数(需要返回多个值)<br>3.在要实现的函数内调用结构体返回多个值<br>4.使用函数返回结果</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">step <span class="number">1</span> :定义结构体 </span><br><span class="line"><span class="keyword">struct</span>  <span class="title class_">PointStruct</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">float</span> without_floor;</span><br><span class="line">    <span class="type">int</span> only_floor;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">step <span class="number">2</span> :定义函数 </span><br><span class="line"><span class="comment">//定义了一个返回值为PointStruct的函数，函数名为filterFloorPoint</span></span><br><span class="line"><span class="function">PointStruct <span class="title">filterFloorPoint</span><span class="params">( <span class="type">int</span> max_iterations,<span class="type">float</span> in_floor_max_angle,<span class="type">float</span> Distance_Threshold)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> result_iterations;</span><br><span class="line">    <span class="type">float</span> result_angle_add_distance;</span><br><span class="line">    result_iterations=max_iterations*<span class="number">100</span>;</span><br><span class="line">    result_angle_add_distance=in_floor_max_angle*Distance_Threshold;</span><br><span class="line">    <span class="comment">//此时，我们想要函数返回result_iterations和result_angle_add_distance两个值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//step 3:调用结构体返回多个值 </span></span><br><span class="line">    <span class="comment">//调用PointStruct结构体返回多个值 </span></span><br><span class="line">    PointStruct use_PointStruct;  <span class="comment">//use_PointStruct 可以换成你自己想要的名称</span></span><br><span class="line">    use_PointStruct.without_floor=result_iterations;</span><br><span class="line">    use_PointStruct.only_floor=result_angle_add_distance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> use_PointStruct; <span class="comment">//只需要返回 use_PointStruct即可</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"> <span class="comment">//step 4:调用结构体返回的多个值</span></span><br><span class="line"><span class="type">int</span> max_iterations=<span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> in_floor_max_angle=<span class="number">10.0</span>;</span><br><span class="line"><span class="type">float</span> Distance_Threshold=<span class="number">10.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> without_floor_cloud_ptr;</span><br><span class="line"><span class="type">float</span> only_floor_cloud_ptr;  </span><br><span class="line">PointStruct  use_PointStruct_now; <span class="comment">//调用PointStruct结构体</span></span><br><span class="line"></span><br><span class="line"> use_PointStruct_now=<span class="built_in">filterFloorPoint</span>(max_iterations,in_floor_max_angle,Distance_Threshold); <span class="comment">//调用函数</span></span><br><span class="line"> without_floor_cloud_ptr=use_PointStruct_now.without_floor; <span class="comment">//取第一个函数返回值</span></span><br><span class="line"> only_floor_cloud_ptr=use_PointStruct_now.only_floor;<span class="comment">//取第二个函数返回值</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google开源项目风格指南——Python风格规范</title>
      <link href="/2022/12/08/python-feng-ge-gui-fan/"/>
      <url>/2022/12/08/python-feng-ge-gui-fan/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/contents/">Python风格指南(中文版)</a></p><h3 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h3><p>如果你先学习了c++，记得不要在行尾加分号，也不要用分号将两条命令放在同一行</p><h3 id="行长度"><a href="#行长度" class="headerlink" title="行长度"></a>行长度</h3><p>每行不超过80个字符。<br>但是：url/路径等不要分割</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Yes: foo_bar(self, width, height, color=<span class="string">'black'</span>, design=<span class="literal">None</span>, x=<span class="string">'foo'</span>,</span><br><span class="line">             emphasis=<span class="literal">None</span>, highlight=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (width == <span class="number">0</span> <span class="keyword">and</span> height == <span class="number">0</span> <span class="keyword">and</span></span><br><span class="line">         color == <span class="string">'red'</span> <span class="keyword">and</span> emphasis == <span class="string">'strong'</span>):</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Yes:  <span class="comment"># See details at</span></span><br><span class="line">      <span class="comment"># http://www.example.com/us/developer/documentation/api/content/v2.0/csv_file_name_extension_full_specification.html</span></span><br><span class="line"></span><br><span class="line">No:  <span class="comment"># See details at</span></span><br><span class="line">     <span class="comment"># http://www.example.com/us/developer/documentation/api/content/\</span></span><br><span class="line">     <span class="comment"># v2.0/csv_file_name_extension_full_specification.html</span></span><br></pre></td></tr></tbody></table></figure><h3 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h3><p><strong>宁缺毋滥</strong></p><h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><p><strong>用4个空格来缩进代码</strong><br>绝对不要用tab, 也不要tab和空格混用. 建议使用4空格的悬挂式缩进</p><h3 id="序列元素尾部逗号"><a href="#序列元素尾部逗号" class="headerlink" title="序列元素尾部逗号"></a>序列元素尾部逗号</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Yes:   golomb3 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">Yes:   golomb4 = [</span><br><span class="line">           <span class="number">0</span>,</span><br><span class="line">           <span class="number">1</span>,</span><br><span class="line">           <span class="number">4</span>,</span><br><span class="line">           <span class="number">6</span>,</span><br><span class="line">       ]</span><br><span class="line"></span><br><span class="line">No:    golomb4 = [</span><br><span class="line">           <span class="number">0</span>,</span><br><span class="line">           <span class="number">1</span>,</span><br><span class="line">           <span class="number">4</span>,</span><br><span class="line">           <span class="number">6</span></span><br><span class="line">       ]</span><br></pre></td></tr></tbody></table></figure><h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h3><p>顶级定义之间空两行, 比如函数或者类定义. 方法定义, 类定义与第一个方法之间, 都应该空一行. 函数或方法中, 某些地方要是你觉得合适, 就空一行.</p><h3 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h3><p>括号内不要有空格<br>不要在逗号, 分号, 冒号前面加空格, 但应该在它们后面加(除了在行尾)<br>参数列表, 索引或切片的左括号前不应加空格<br>……</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>参考《编写可读代码的艺术》</p><h3 id="标点符号-拼写和语法"><a href="#标点符号-拼写和语法" class="headerlink" title="标点符号,拼写和语法"></a>标点符号,拼写和语法</h3><p>注意标点符号,拼写和语法</p><p>注释应有适当的大写和标点,句子应该尽量完整.对于诸如在行尾上的较短注释,可以不那么正式,但是也应该尽量保持风格一致</p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>如果一个类不继承自其它类, 就显式的从object继承. 嵌套类也一样.(除非是为了和 python2 兼容)</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>避免在循环中用+和+=操作符来累加字符串. 由于字符串是不可变的, 这样做会创建不必要的临时对象, 并且导致二次方而不是线性的运行时间. 作为替代方案, 你可以将每个子串加入列表, 然后在循环结束后用 <code>.join</code> 连接列表. (也可以将每个子串写入一个 <code>cStringIO.StringIO</code> 缓存中.)</p><p>为多行字符串使用三重双引号”””而非三重单引号’’’. </p><h3 id="文件和sockets"><a href="#文件和sockets" class="headerlink" title="文件和sockets"></a>文件和sockets</h3><p><strong>在文件和sockets结束时, 显式的关闭它</strong></p><h3 id="TODO注释"><a href="#TODO注释" class="headerlink" title="TODO注释"></a>TODO注释</h3><p>为临时代码使用TODO注释, 它是一种短期解决方案. 不算完美, 但够好了.</p><h3 id="导入格式"><a href="#导入格式" class="headerlink" title="导入格式"></a>导入格式</h3><p>每个导入应该独占一行, <code>typing</code> 的导入除外</p><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>通常每个语句应该独占一行</p><p>不过, 如果测试结果与测试语句在一行放得下, 你也可以将它们放在同一行. 如果是if语句, 只有在没有else时才能这样做</p><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><p>模块名写法: module_name ;<br>包名写法: package_name ;<br>类名: ClassName ;<br>方法名: method_name ;<br>异常名: ExceptionName ;<br>函数名: function_name ;<br>全局常量名: GLOBAL_CONSTANT_NAME ;<br>全局变量名: global_var_name ;<br>实例名: instance_var_name ;<br>函数参数名: function_parameter_name ;<br>局部变量名: local_var_name</p><p>函数名,变量名和文件名应该是描述性的,尽量避免缩写,特别要避免使用非项目人员不清楚难以理解的缩写,不要通过删除单词中的字母来进行缩写. 始终使用 .py 作为文件后缀名,不要用破折号.</p><p>应该避免的名称</p><ul><li>单字符名称, 除了计数器和迭代器,作为 try/except 中异常声明的 e,作为 with 语句中文件句柄的 f.</li><li>包/模块名中的连字符(-)</li><li>双下划线开头并结尾的名称(Python保留, 例如__init__)</li></ul><h3 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h3><p>即使是一个打算被用作脚本的文件, 也应该是可导入的. 并且简单的导入不应该导致这个脚本的主功能(main functionality)被执行, 这是一种副作用. 主功能应该放在一个main()函数中.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure><h3 id="函数长度"><a href="#函数长度" class="headerlink" title="函数长度"></a>函数长度</h3><p>推荐函数功能尽量集中,简单,小巧</p><p>不对函数长度做硬性限制.但是若一个函数超过来40行,推荐考虑一下是否可以在不损害程序结构的情况下对其进行分解. </p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux实用工具</title>
      <link href="/2022/12/07/linux-shi-yong-gong-ju/"/>
      <url>/2022/12/07/linux-shi-yong-gong-ju/</url>
      
        <content type="html"><![CDATA[<h3 id="截图工具"><a href="#截图工具" class="headerlink" title="截图工具"></a>截图工具</h3><p>最好用的当属Kazan和Shutter，前者不仅能截屏还能录屏；后者截屏功能相对更加强大。<br>命令行apt安装即可。</p><h3 id="办公软件"><a href="#办公软件" class="headerlink" title="办公软件"></a>办公软件</h3><p>WPS，支持国产</p><h3 id="远程控制"><a href="#远程控制" class="headerlink" title="远程控制"></a>远程控制</h3><p>用过Google chrome desktop, Teamviewer等一大堆软件，现在表示还是向日(Sunlogin)最好用…</p><h3 id="c-编译软件"><a href="#c-编译软件" class="headerlink" title="c++编译软件"></a>c++编译软件</h3><p>有很多，推荐一款常用的 Bazel</p><h3 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h3><p>用来用去，最好的还是VSCode。此外你也可以尝试Atom</p>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有价值的网站</title>
      <link href="/2022/12/07/you-jie-zhi-de-wang-zhan/"/>
      <url>/2022/12/07/you-jie-zhi-de-wang-zhan/</url>
      
        <content type="html"><![CDATA[<p>本文分为两部分，前半部分主要涉及计算机编程，后半部分涉及机器人学。无论你是想转码的小白，初学的开发者，还是机器人工程师，希望这篇文章都能给你带来新的知识。</p><h2 id="一些CS网站分享"><a href="#一些CS网站分享" class="headerlink" title="一些CS网站分享"></a>一些CS网站分享</h2><h3 id="Google开源项目风格指南-中文版"><a href="#Google开源项目风格指南-中文版" class="headerlink" title="Google开源项目风格指南 (中文版)"></a><a href="https://zh-google-styleguide.readthedocs.io/en/latest/contents/">Google开源项目风格指南</a> (中文版)</h3><p>养成一套良好的代码编写习惯非常重要，无论是对于开发者还是阅读者 <span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="一些机器人学网站分享"><a href="#一些机器人学网站分享" class="headerlink" title="一些机器人学网站分享"></a>一些机器人学网站分享</h2>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科学上网（2022年12月） 适用于Linux &amp; Windows</title>
      <link href="/2022/12/05/ru-he-ke-xue-shang-wang/"/>
      <url>/2022/12/05/ru-he-ke-xue-shang-wang/</url>
      
        <content type="html"><![CDATA[<p>作为机器人工程师，我们不得不使用stackoverflow，github等网站。</p><p>由于众所周知的原因，我们需要科学上网工具，在此推荐一款便宜好用的梯子，适用于全平台:<br><a href="https://windscribe.com/">Windscribe</a><br>它不仅节点多，速度快，而且便宜。支持按照节点数购买，一个地区的节点一个月仅需一刀。</p><p>如果你的电脑不能打开windscibe官网，可以在<a href="https://github.com/rd-zhang/windscribe_deb">这里</a>下载deb安装包。</p>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《编写可读代码的艺术》(一)</title>
      <link href="/2022/12/02/bian-xie-ke-du-dai-ma-de-yi-zhu-1/"/>
      <url>/2022/12/02/bian-xie-ke-du-dai-ma-de-yi-zhu-1/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>第一次被推荐这本书的时候我已经写了两年代码。尽管自己已经形成了一套命名和注释方法，但是对于代码的可阅读性并没有太过深入的思考。_<a href="https://mcusoft.files.wordpress.com/2015/04/the-art-of-readable-code.pdf">The Art of Readable Code</a>_ (中文译名<a href="https://awesome-programming-books.github.io/clean-code/%E7%BC%96%E5%86%99%E5%8F%AF%E8%AF%BB%E4%BB%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF.pdf">《编写可读代码的艺术》</a>)通过15个章节从简到繁，轻松又愉快的使你明白如何写出‘易于理解’的代码。</p><h3 id="第1章—代码应当易于理解"><a href="#第1章—代码应当易于理解" class="headerlink" title="第1章—代码应当易于理解"></a>第1章—代码应当易于理解</h3><p><strong>代码易于理解</strong> 是关键思想。<br>代码的写法应当使别人理解它所需的时间最小化。但是虽然减少代码行数是一个重要目标，我们的最终目标仍然是把理解代码所需时间最小化。<br>编写代码时要经常站在别的角度，想一想自己写的代码别能否轻松理解。</p><h1 id="Part-1-表明层次的改进"><a href="#Part-1-表明层次的改进" class="headerlink" title="Part 1. 表明层次的改进"></a>Part 1. 表明层次的改进</h1><p>可读性之旅从“表面层次”的改进开始：选择好的名字、写好的注释以及把代码整洁的写成更好的格式。</p><h3 id="第2章—把信息装进名字里"><a href="#第2章—把信息装进名字里" class="headerlink" title="第2章—把信息装进名字里"></a>第2章—把信息装进名字里</h3><p>选择专业的词语：比如fetchPage相比getPage显得更加专业而清晰；<br>避免泛泛的名字: 如tmp，retval。好的名字应当描述变量的目的或者它承载的值，除非你确定你只是临时的用一次tmp;<br>使用具体的名字更细致的描述：<a href="https://blog.csdn.net/fuhanghang/article/details/119805459">这里</a>总结了一些常用的命名方法。个人偏爱使用下划线法命名，把每个变量具体干什么使用起英文短语命名，如 <em>log_finishedinfo_when_reach_terminal</em> ;<br>给变量名加上重要细节：比如JS中的 <em>getTime()</em> 返回单位是毫秒，那么就可以给变量加上 _<em>ms</em> 的后缀;<br>名字的长度：应当遵循作用域越大名字越长的原则，比如一个字母 <em>m</em> 如果作用于全域，读者很可能不知道他是干什么的。这就好比旅行，越长的假期你总是会带越多的行李；<br>有目的使用下划线：你可以在类成员和局部变量后面加上下划线来区分他们。</p><h3 id="第3章—不会误解的名字"><a href="#第3章—不会误解的名字" class="headerlink" title="第3章—不会误解的名字"></a>第3章—不会误解的名字</h3><p><em>Filter()</em> 是一个很好的例子，我的意思是它是一个很糟糕的命名。因为读者根本不知道这个函数是用于 <strong>筛选出</strong> 一部分结果还是 <strong>筛选掉</strong> 一部分结果！<br>而涉及到bool值的时候尽量避免诸如多重否定的文字游戏。比如 <em>is_task_finished</em> 的返回值能够直观的说明任务是否完成了。<br>对于区间的表示，推荐使用一套约定俗成的方法：</p><ul><li>min, max 表示极限</li><li>first, last 表示包含的范围(闭区间)</li><li>begin, end 表示包含的范围(开区间)</li><li>etc…</li></ul><p>总之，你应该三思，别人是否会对命名产生不一样的理解。</p><h3 id="第4章—审美"><a href="#第4章—审美" class="headerlink" title="第4章—审美"></a>第4章—审美</h3><p>好的代码应该看上去遵循 <strong>养眼</strong> ，三条原则：</p><ul><li>使用一致的布局，让读者很快就能习惯这种风格</li><li>让相似的代码看上去相似</li><li>把相关的代码分组，形成代码块</li></ul><p>编程的大部分时间都花在看代码上，浏览代码的速度越快，人们越容易使用它：</p><ul><li>重新安排换行来保持一致和紧凑；</li><li>用方法来整理不规则的东西；</li><li>在需要的时候使用列对齐；</li><li>选择一个有意义的顺序，比如重要性排序，并保持一致的使用它；</li><li>把声明按照块组织起来，按照逻辑分组，添加注释；</li><li>把代码分成段落，比如按照步骤划分；</li><li>个人风格要保证一致性，比如大括号的位置。</li></ul><h3 id="第5章—该写什么样的注释"><a href="#第5章—该写什么样的注释" class="headerlink" title="第5章—该写什么样的注释"></a>第5章—该写什么样的注释</h3><p> 注释的目的是尽量帮助读者了解得和作者一样多：</p><ul><li>不要为那些从代码本身就能快速推断的事实写注释</li><li>不要为了注释而注释</li><li>与其给名字不好的函数写注释，不如把其名字先改好，即 <strong>好代码 &gt; 坏代码 + 好注释</strong></li></ul><p> 应该记录下来的想法包括：</p><ul><li>为什么这个地方代码写成这样而不是别的？</li><li>代码中有缺陷的地方，可以写一个 _TODO: XXX_；</li><li>常量为什么定义这个值？ (比如 <em>length = 10 is big enough to describe the object shape</em> )。</li></ul><p>站在读者的立场上思考：</p><ul><li>预料到那些地方会使读者不解或出乎意料，并加上注释；</li><li>在文件/类的级别上使用“全局观”注释，以解释他们是如何一起工作的</li><li>用注释作为代码块的总结。</li></ul><h3 id="第6章—写出言简意赅的注释"><a href="#第6章—写出言简意赅的注释" class="headerlink" title="第6章—写出言简意赅的注释"></a>第6章—写出言简意赅的注释</h3><p> <strong>注释要有很高的信息率和空间率</strong></p><ul><li>让注释保持紧凑，能写一行的注释不要写三行；</li><li>避免使用不明确的代词，不要用 <em>it</em> 这种模糊词语；</li><li>润色粗糙的句子(这可能考验语文功底…)；</li><li>精确描述函数的行为；</li><li>用输入输出例子来描述特殊的情况(对于工程师来说这无疑更直观)；</li><li>声明代码的意图；</li><li>使用具名函数。python 等语言能这么调用： <em>connect(timeout = 10, use_encryption = False)</em> ；</li><li>采用信息量高的词语；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《编写可读代码的艺术》(二)</title>
      <link href="/2022/12/02/bian-xie-ke-du-dai-ma-de-yi-zhu-2/"/>
      <url>/2022/12/02/bian-xie-ke-du-dai-ma-de-yi-zhu-2/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>第一次被推荐这本书的时候我已经写了两年代码。尽管自己已经形成了一套命名和注释方法，但是对于代码的可阅读性并没有太过深入的思考。_<a href="https://mcusoft.files.wordpress.com/2015/04/the-art-of-readable-code.pdf">The Art of Readable Code</a>_ (中文译名<a href="https://awesome-programming-books.github.io/clean-code/%E7%BC%96%E5%86%99%E5%8F%AF%E8%AF%BB%E4%BB%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF.pdf">《编写可读代码的艺术》</a>)通过15个章节从简到繁，轻松又愉快的使你明白如何写出‘易于理解’的代码。</p><h1 id="Part-2-简化循环和逻辑"><a href="#Part-2-简化循环和逻辑" class="headerlink" title="Part 2. 简化循环和逻辑"></a>Part 2. 简化循环和逻辑</h1><p>这一部分将深入讨论程序的“循环和逻辑”：控制流、逻辑表达式等等。我们将试着最小化代码中的“思维包袱”来达到目的。</p><h3 id="第7章—把控制流变得易读"><a href="#第7章—把控制流变得易读" class="headerlink" title="第7章—把控制流变得易读"></a>第7章—把控制流变得易读</h3><p>条件语句中左右两侧分别是“被询问的”和“用来作比较的标准”，比如 <em>if(length &gt; 10)</em> 看起来就很自然；<br><em>if/else</em> 语句处理顺序：正常逻辑优先，简单逻辑优先，可疑或有趣项优先；<br>对于C语言中的三目表达式，更重要的是减少理解其逻辑的时间，因此要注意代码行数与复杂度之间的平衡；<br>避免 <em>do/while</em> 循环，尽量换成 <em>while</em> 或其他循环；<br>可以在函数中提前 <em>return</em> 返回，但要避免使用臭名昭著的 <em>goto</em> ；<br><strong>最小化嵌套</strong> “故意嵌套很深的代码就是一坨屎” ——图图。你可以通过提前返回来减少嵌套。</p><h3 id="第8章—拆分超长的表达式"><a href="#第8章—拆分超长的表达式" class="headerlink" title="第8章—拆分超长的表达式"></a>第8章—拆分超长的表达式</h3><p>如果你百度一下，可能会发现人脑的容量高达7亿TB。但是其实人脑的RAM非常小，以至于大脑同时只能考虑3~4件事。本章的核心思想是—— <strong>把超长的表达式拆分成更容易理解的小块</strong> 。<br>一个简单的例子件事，把某一行代码拆分为两行。第一行多定义一个变量，即“解释变量”，他能够帮助读者理解这个值是干什么的；<br>你也可以使用一个总结性的变量，比如一个bool值，来解释一些拗口的判断式，并利用 <em>if/else</em> 辅助；<br>使用电路学中的“德摩根定理”，它的核心思想是通过整体取反的方式，在不改变逻辑的情况下使判断式更好理解(即前文提到的避免多重否定)；<br>不要滥用短路逻辑；<br>提取出大量重复的表达式为变量，例如C++中的宏(尽管有时并不建议使用宏，但当它对可读性利大于弊时可以采用)。</p><h3 id="第9章—变量与可读性"><a href="#第9章—变量与可读性" class="headerlink" title="第9章—变量与可读性"></a>第9章—变量与可读性</h3><p>对于变量的草率运用会让程序更难理解：</p><ul><li>变量越多，越难以跟踪他们的动向；</li><li>变量的作用域越大，就需要跟踪它的动向越久；</li><li>变量改变地越频繁，就越难以跟踪它的当前值。</li></ul><p>如何处理：</p><ul><li>减少无价值的临时变量，比如根本就没有必要定义 <em>now = datetime.datetime.now()</em> ，直接使用这个时间函数即可；</li><li>减少控制流变量，避免使用 <em>done</em> 这样的“控制流变量”；</li><li>缩小变量作用域，防止名称污染，让你的变量对尽量少的代码行可见；</li><li>只写一次的变量更好，因为常量往往不会引来麻烦。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《编写可读代码的艺术》(三)</title>
      <link href="/2022/12/02/bian-xie-ke-du-dai-ma-de-yi-zhu-3/"/>
      <url>/2022/12/02/bian-xie-ke-du-dai-ma-de-yi-zhu-3/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>第一次被推荐这本书的时候我已经写了两年代码。尽管自己已经形成了一套命名和注释方法，但是对于代码的可阅读性并没有太过深入的思考。_<a href="https://mcusoft.files.wordpress.com/2015/04/the-art-of-readable-code.pdf">The Art of Readable Code</a>_ (中文译名<a href="https://awesome-programming-books.github.io/clean-code/%E7%BC%96%E5%86%99%E5%8F%AF%E8%AF%BB%E4%BB%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF.pdf">《编写可读代码的艺术》</a>)通过15个章节从简到繁，轻松又愉快的使你明白如何写出‘易于理解’的代码。</p><h1 id="Part-3-重新组织代码"><a href="#Part-3-重新组织代码" class="headerlink" title="Part 3. 重新组织代码"></a>Part 3. 重新组织代码</h1><p>该部分会讨论可以在函数级别对代码做更大的改动。</p><h3 id="第10章—抽取不相关的子问题"><a href="#第10章—抽取不相关的子问题" class="headerlink" title="第10章—抽取不相关的子问题"></a>第10章—抽取不相关的子问题</h3><p><strong>积极地发现并抽取出不相关的子逻辑</strong></p><ul><li>如果足够多行数的代码并不是在解决当前问题，那么把他们放到独立的函数中去；</li><li>你可以自己写一些工具性的代码来填充编程语言中的空白，比如C++中没有简单的方法来读取整个文件，你可以自己写一个 <em>ReadFileToString()</em> 并当做库函数使用；</li><li>创建大量通用代码，这样你代码的其余部分会更小而且容易思考；</li><li>简化已有接口，按需重塑接口；</li><li>最后要记住，避免 <strong>过犹不及</strong> ！</li></ul><h3 id="第11章—一次只做一件事"><a href="#第11章—一次只做一件事" class="headerlink" title="第11章—一次只做一件事"></a>第11章—一次只做一件事</h3><p>把代码组织得一次只做一件事：</p><ul><li>列出代码所做的所有任务，其中一些可以变成独立的函数/类；</li><li>尽力把这些任务拆分到不同的函数中。</li></ul><h3 id="第12章—把想法变成代码"><a href="#第12章—把想法变成代码" class="headerlink" title="第12章—把想法变成代码"></a>第12章—把想法变成代码</h3><p>用自然语言描述程序来帮助写出更自然的代码:</p><ul><li>清楚地描述逻辑；</li><li>了解所使用的编程语言的库函数，比如一些提示框内的建议很有帮助；</li><li>首先把本方法用于小块代码，然后应用于更大的问题。</li></ul><h3 id="第13章—少写代码"><a href="#第13章—少写代码" class="headerlink" title="第13章—少写代码"></a>第13章—少写代码</h3><p><strong>最好读的代码就是没有代码</strong></p><ul><li>别费劲去做你不太需要的功能；</li><li>质疑并拆分你的需求；</li><li>记得思考你的输入和输出是什么，并不是任何时候输入都是很复杂的；</li><li>让你的代码库越小、越轻量级越好；</li><li>熟悉你周边的库，避免重复造轮子。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《编写可读代码的艺术》(四|实战)(完)</title>
      <link href="/2022/12/02/bian-xie-ke-du-dai-ma-de-yi-zhu-4/"/>
      <url>/2022/12/02/bian-xie-ke-du-dai-ma-de-yi-zhu-4/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>第一次被推荐这本书的时候我已经写了两年代码。尽管自己已经形成了一套命名和注释方法，但是对于代码的可阅读性并没有太过深入的思考。_<a href="https://mcusoft.files.wordpress.com/2015/04/the-art-of-readable-code.pdf">The Art of Readable Code</a>_ (中文译名<a href="https://awesome-programming-books.github.io/clean-code/%E7%BC%96%E5%86%99%E5%8F%AF%E8%AF%BB%E4%BB%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF.pdf">《编写可读代码的艺术》</a>)通过15个章节从简到繁，轻松又愉快的使你明白如何写出‘易于理解’的代码。</p><h1 id="Part-4-精选话题"><a href="#Part-4-精选话题" class="headerlink" title="Part 4. 精选话题"></a>Part 4. 精选话题</h1><p>在本书的最后一部分，之前讨论的各种技巧会应用到两个精选的话题中。</p><h3 id="第14章—测试与可读性"><a href="#第14章—测试与可读性" class="headerlink" title="第14章—测试与可读性"></a>第14章—测试与可读性</h3><p><strong>测试应当具有可读性，以便使其他程序员可以舒服的改变或者增加测试</strong><br>记住对使用者隐去不重要的细节，以便更重要的细节会更为突出；<br>大多数的测试都能精炼成“对于xx的输入/情况，期望有xx的输出/行为”；<br><strong>让错误消息具有可读性</strong><br>多用 <em>assert()</em>;<br>手工打造错误消息，选择好的测试输入，又简单又能完成工作的测试值更好；<br>与其建立单个“完美”输入来完整地执行代码，不如写多个小测试，因为他们更具有可读性；<br>为测试函数命名，但是避免“test”这种没什么意义的名字；</p><p>下面我们来看一个例子，在这段代码中</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test1</span><span class="params">()</span></span>{</span><br><span class="line">  vector&lt;ScoredDocument&gt; docs;</span><br><span class="line">  docs.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">  docs[<span class="number">0</span>].url = <span class="string">"http://example.com"</span></span><br><span class="line">  docs[<span class="number">0</span>].score = <span class="number">-5.0</span>;</span><br><span class="line">  docs[<span class="number">1</span>].url = <span class="string">"http://example.com"</span></span><br><span class="line">  docs[<span class="number">1</span>].score = <span class="number">1</span>;</span><br><span class="line">  docs[<span class="number">2</span>].url = <span class="string">"http://example.com"</span></span><br><span class="line">  docs[<span class="number">2</span>].score = <span class="number">4</span>;</span><br><span class="line">  docs[<span class="number">3</span>].url = <span class="string">"http://example.com"</span></span><br><span class="line">  docs[<span class="number">3</span>].score = <span class="number">-99998.7</span>;</span><br><span class="line">  docs[<span class="number">4</span>].url = <span class="string">"http://example.com"</span></span><br><span class="line">  docs[<span class="number">4</span>].score = <span class="number">3.0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SortAndFileterDocs</span>(&amp;Docs);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span>(docs.<span class="built_in">size</span>() == <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">assert</span>(docs[<span class="number">0</span>].score == <span class="number">4</span>);</span><br><span class="line">  <span class="built_in">assert</span>(docs[<span class="number">1</span>].score == <span class="number">3.0</span>);</span><br><span class="line">  <span class="built_in">assert</span>(docs[<span class="number">2</span>].score == <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这段测试代码至少犯了8条错误：</p><ul><li>测试太长，充满不重要的细节</li><li>增加新测试将很不容易</li><li>测试失败的消息不是很有帮助。如果测试失败，它仅仅是“Assertion failed:docs.size() == 3”，对于调试没有什么帮助</li><li>这段测试代码想同时测完所有东西。拆分为多个测试会更具可读性</li><li>测试的输入不是很简单，尤其是“-99998.7”这种夸张的数值</li><li>它没有其他测试其他极端输入，比如空输入向量，很长的向量等</li><li>函数名字没有什么实意</li></ul><p>存在一种对测试较好的开发方式，即大名鼎鼎的测试驱动开发(TDD)。其支持者相信这种流程对没有测试的代码来将会做出极大的质量改进。无论你选择那种驱动开发方式，至少通过在写代码时候想着测试这件事能够帮助我们把代码写的更好。</p><h3 id="第15章—设计并改进“分钟-x2F-小时计数器”"><a href="#第15章—设计并改进“分钟-x2F-小时计数器”" class="headerlink" title="第15章—设计并改进“分钟/小时计数器”"></a>第15章—设计并改进“分钟/小时计数器”</h3><p>见 <a href="https://awesome-programming-books.github.io/clean-code/%E7%BC%96%E5%86%99%E5%8F%AF%E8%AF%BB%E4%BB%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF.pdf">编写可读代码的艺术</a> 第十五章</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++实用的库</title>
      <link href="/2022/12/01/c-you-yong-de-ku/"/>
      <url>/2022/12/01/c-you-yong-de-ku/</url>
      
        <content type="html"><![CDATA[<p>c++和Python不同，后者有pip这样的工具来管理模组。c++很多库需要自己下载源码编译。本文旨在分享那些实用的库的安装使用方法</p><h3 id="Boost库"><a href="#Boost库" class="headerlink" title="Boost库"></a>Boost库</h3><p>一定首先安装Boos库，他是很多其他库的基石</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mpi-default-dev　</span><br><span class="line">sudo apt-get install libicu-dev　   </span><br><span class="line">sudo apt-get install python-dev　</span><br><span class="line">sudo apt-get install libbz2-dev　</span><br></pre></td></tr></tbody></table></figure><p>boost库源文件下载 <a href="https://sourceforge.net/projects/boost/">https://sourceforge.net/projects/boost/</a><br>解压后进入文件夹执行</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./bootstrap.sh</span><br><span class="line">sudo ./b2</span><br><span class="line">sudo ./b2 install</span><br></pre></td></tr></tbody></table></figure><p><strong>这个过程可能很久..</strong><br><a href="https://www.cnblogs.com/nanmi/p/15161211.html">安装Boost库</a></p><h3 id="NumCPP"><a href="#NumCPP" class="headerlink" title="NumCPP"></a>NumCPP</h3><p>熟悉Python的人一定用过NumPy，同理c++也有这样的库。<br><a href="https://www.cnblogs.com/nanmi/p/15161211.html">安装NumCPP库</a></p><h3 id="openCV"><a href="#openCV" class="headerlink" title="openCV"></a>openCV</h3>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++编译那些事儿</title>
      <link href="/2022/12/01/c-bian-yi-na-xie-shi/"/>
      <url>/2022/12/01/c-bian-yi-na-xie-shi/</url>
      
        <content type="html"><![CDATA[<p>我首先深入学习了Python，然后才是c++。尽管本科一年级学过c语言，但是在visual studio里面的一件编译运行和在Linux下手动编译很不一样。</p><h2 id="为什么要编译"><a href="#为什么要编译" class="headerlink" title="为什么要编译"></a>为什么要编译</h2><p>说白了就是把高级语言翻译成汇编语言、机器码这种计算机能够理解的语言。Python相当于边编译边运行，而c++先编译完再运行，后者自然速度起飞。</p><h2 id="编译工具"><a href="#编译工具" class="headerlink" title="编译工具"></a>编译工具</h2><p>长话短说，对于Linux下的cpp文件，我们可以使用免费开源的g++，比如<code>g++ main.cpp -o demo</code> 是把main.cpp编译并生成名为demo的可执行文件。</p><p>g++是GCC中的GUN C++ Compiler。当程序只有一个源文件时，直接就可以用gcc/g++命令编译。但是当程序包含很多个源文件时，这是一件很头疼的事情！</p><p>所以出现了make工具！make工具可以看成是一个智能的批处理工具，它本身并没有编译和链接的功能，而是用类似于批处理的方式—通过调用makefile文件中用户指定的命令来进行编译和链接的。</p><p>makefile是什么？简单的说就像一首歌的乐谱，make工具就像指挥家，指挥家根据乐谱指挥整个乐团怎么样演奏，make工具就根据makefile中的命令进行编译和链接的。makefile命令中就包含了调用g++（也可以是别的编译器）去编译某个源文件的命令。</p><h3 id="make-vs-Cmake"><a href="#make-vs-Cmake" class="headerlink" title="make vs Cmake"></a>make vs Cmake</h3><p>makefile在一些简单的工程完全可以人工手下，但是当工程非常大的时候，手写makefile也是非常麻烦的，如果换了个平台makefile又要重新修改。</p><p>这时候就出现了Cmake这个工具，cmake就可以更加简单的生成makefile文件给上面那个make用。当然cmake还有其他功能，就是可以跨平台生成对应平台能用的makefile，你不用再自己去修改了。</p><p>可是cmake根据什么生成makefile呢？它又要根据一个叫CMakeLists.txt文件去生成makefile。</p><h3 id="Cmake-vs-Bazel"><a href="#Cmake-vs-Bazel" class="headerlink" title="Cmake vs Bazel"></a>Cmake vs Bazel</h3><p>Bazel是Google开源的编译构建工具，以Monolithic Repository为理念。与makefile &amp; CMake不同，Bazel另起炉灶，采用client/server运行模式，为云编译而生。Bazel工具将编译过程分三个阶段：Load Phase/Analysis Phase/Execution phase。研发人员实现workspace/build/.bzl三种文件，Bazel执行这些文件生成action graph，执行action来构建项目。</p><h2 id="怎么选择编译工具？"><a href="#怎么选择编译工具？" class="headerlink" title="怎么选择编译工具？"></a>怎么选择编译工具？</h2><p>因为Bazel采用了类似Python的语法，所以其学习曲线相比CMake要平缓一些。Bazel对thirdparty支持还是非常友好的。</p><p>综合考虑时，CMake是一个尽管保守但仍旧不错的选择。我个人建议，如果你的团队在用Bazel，则可以尝试Bazel。否则仍然推荐先使用Cmake。</p><p><a href="https://blog.csdn.net/hblhly/article/details/80740493">ref1</a><br><a href="https://zhuanlan.zhihu.com/p/112712537">ref2</a><br><a href="https://www.jianshu.com/p/d01472734a78">ref3</a></p>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变得更强</title>
      <link href="/2022/12/01/bian-de-geng-qiang/"/>
      <url>/2022/12/01/bian-de-geng-qiang/</url>
      
        <content type="html"><![CDATA[<h3 id="漫画资本论"><a href="#漫画资本论" class="headerlink" title="漫画资本论"></a>漫画资本论</h3><p>一本轻松有趣的资本论入门漫画书，主要讲述的是资本论三卷中第一卷内容，让你对全书有一个大致了解。适合零基础的同志学习。<br><a href="https://www.bilibili.com/read/cv10516935/">漫画资本论(上)</a>  <a href="https://www.bilibili.com/read/cv10517038/">漫画资本论(下)</a></p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书 </tag>
            
            <tag> 变得更强 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>待更新清单</title>
      <link href="/2022/12/01/dai-geng-xin/"/>
      <url>/2022/12/01/dai-geng-xin/</url>
      
        <content type="html"><![CDATA[<h3 id="c-学习查漏补缺"><a href="#c-学习查漏补缺" class="headerlink" title="c++学习查漏补缺"></a>c++学习查漏补缺</h3><h3 id="c-库函数过一遍"><a href="#c-库函数过一遍" class="headerlink" title="c++库函数过一遍"></a>c++库函数过一遍</h3><h3 id="数据结构和算法学习系列"><a href="#数据结构和算法学习系列" class="headerlink" title="数据结构和算法学习系列"></a>数据结构和算法学习系列</h3><h3 id="一些有趣的开源项目分享"><a href="#一些有趣的开源项目分享" class="headerlink" title="一些有趣的开源项目分享"></a>一些有趣的开源项目分享</h3><h3 id="生活随笔、杂谈系列"><a href="#生活随笔、杂谈系列" class="headerlink" title="生活随笔、杂谈系列"></a>生活随笔、杂谈系列</h3>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
