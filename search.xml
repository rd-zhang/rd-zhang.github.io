<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>编写高质量代码改善Python程序的 91 个建议</title>
      <link href="/2022/12/14/bian-xie-gao-zhi-liang-dai-ma-gai-shan-python-cheng-xu-de-91-ge-jian-yi/"/>
      <url>/2022/12/14/bian-xie-gao-zhi-liang-dai-ma-gai-shan-python-cheng-xu-de-91-ge-jian-yi/</url>
      
        <content type="html"><![CDATA[<p><a href="https://l1nwatch.gitbook.io/writing_solid_python_code_gitbook/">ref</a></p><h4 id="建议-1：理解-Pythonic-概念"><a href="#建议-1：理解-Pythonic-概念" class="headerlink" title="建议 1：理解 Pythonic 概念"></a>建议 1：理解 Pythonic 概念</h4><h4 id="建议-2：编写-Pythonic-代码"><a href="#建议-2：编写-Pythonic-代码" class="headerlink" title="建议 2：编写 Pythonic 代码"></a>建议 2：编写 Pythonic 代码</h4><h4 id="建议-3：理解-Python-与-C-语言的不同之处"><a href="#建议-3：理解-Python-与-C-语言的不同之处" class="headerlink" title="建议 3：理解 Python 与 C 语言的不同之处"></a>建议 3：理解 Python 与 C 语言的不同之处</h4><h4 id="建议-4：在代码中适当添加注释"><a href="#建议-4：在代码中适当添加注释" class="headerlink" title="建议 4：在代码中适当添加注释"></a>建议 4：在代码中适当添加注释</h4><h4 id="建议-5：通过适当添加空行使代码布局更为优雅、合理"><a href="#建议-5：通过适当添加空行使代码布局更为优雅、合理" class="headerlink" title="建议 5：通过适当添加空行使代码布局更为优雅、合理"></a>建议 5：通过适当添加空行使代码布局更为优雅、合理</h4><h4 id="建议-6：编写函数的几个原则"><a href="#建议-6：编写函数的几个原则" class="headerlink" title="建议 6：编写函数的几个原则"></a>建议 6：编写函数的几个原则</h4><h4 id="建议-7：将常量集中到一个文件"><a href="#建议-7：将常量集中到一个文件" class="headerlink" title="建议 7：将常量集中到一个文件"></a>建议 7：将常量集中到一个文件</h4><h4 id="建议-8：利用-assert-语句来发现问题"><a href="#建议-8：利用-assert-语句来发现问题" class="headerlink" title="建议 8：利用 assert 语句来发现问题"></a>建议 8：利用 assert 语句来发现问题</h4><h4 id="建议-9：数据交换值的时候不推荐使用中间变量"><a href="#建议-9：数据交换值的时候不推荐使用中间变量" class="headerlink" title="建议 9：数据交换值的时候不推荐使用中间变量"></a>建议 9：数据交换值的时候不推荐使用中间变量</h4><h4 id="建议-10：充分利用-Lazy-evaluation-的特性"><a href="#建议-10：充分利用-Lazy-evaluation-的特性" class="headerlink" title="建议 10：充分利用 Lazy evaluation 的特性"></a>建议 10：充分利用 Lazy evaluation 的特性</h4><h4 id="建议-11：理解枚举替代实现的缺陷"><a href="#建议-11：理解枚举替代实现的缺陷" class="headerlink" title="建议 11：理解枚举替代实现的缺陷"></a>建议 11：理解枚举替代实现的缺陷</h4><h4 id="建议-12：不推荐使用-type-来进行类型检查"><a href="#建议-12：不推荐使用-type-来进行类型检查" class="headerlink" title="建议 12：不推荐使用 type 来进行类型检查"></a>建议 12：不推荐使用 type 来进行类型检查</h4><h4 id="建议-13：尽量转换为浮点类型后再做除法"><a href="#建议-13：尽量转换为浮点类型后再做除法" class="headerlink" title="建议 13：尽量转换为浮点类型后再做除法"></a>建议 13：尽量转换为浮点类型后再做除法</h4><h4 id="建议-14：警惕-eval-的安全漏洞"><a href="#建议-14：警惕-eval-的安全漏洞" class="headerlink" title="建议 14：警惕 eval() 的安全漏洞"></a>建议 14：警惕 eval() 的安全漏洞</h4><h4 id="建议-15：使用-enumerate-获取序列迭代的索引和值"><a href="#建议-15：使用-enumerate-获取序列迭代的索引和值" class="headerlink" title="建议 15：使用 enumerate() 获取序列迭代的索引和值"></a>建议 15：使用 enumerate() 获取序列迭代的索引和值</h4><h4 id="建议-16：分清-x3D-x3D-与-is-的适用场景"><a href="#建议-16：分清-x3D-x3D-与-is-的适用场景" class="headerlink" title="建议 16：分清 == 与 is 的适用场景"></a>建议 16：分清 == 与 is 的适用场景</h4><h4 id="建议-17：考虑兼容性，尽可能使用-Unicode"><a href="#建议-17：考虑兼容性，尽可能使用-Unicode" class="headerlink" title="建议 17：考虑兼容性，尽可能使用 Unicode"></a>建议 17：考虑兼容性，尽可能使用 Unicode</h4><h4 id="建议-18：构建合理的包层次来管理-module"><a href="#建议-18：构建合理的包层次来管理-module" class="headerlink" title="建议 18：构建合理的包层次来管理 module"></a>建议 18：构建合理的包层次来管理 module</h4><h4 id="建议-19：有节制地使用-from-…-import-语句"><a href="#建议-19：有节制地使用-from-…-import-语句" class="headerlink" title="建议 19：有节制地使用 from … import 语句"></a>建议 19：有节制地使用 from … import 语句</h4><h4 id="建议-20：优先使用-absolute-import-来导入模块"><a href="#建议-20：优先使用-absolute-import-来导入模块" class="headerlink" title="建议 20：优先使用 absolute import 来导入模块"></a>建议 20：优先使用 absolute import 来导入模块</h4><h4 id="建议-21：i-x3D-1-不等于-i"><a href="#建议-21：i-x3D-1-不等于-i" class="headerlink" title="建议 21：i += 1 不等于 ++i"></a>建议 21：i += 1 不等于 ++i</h4><h4 id="建议-22：使用-with-自动关闭资源"><a href="#建议-22：使用-with-自动关闭资源" class="headerlink" title="建议 22：使用 with 自动关闭资源"></a>建议 22：使用 with 自动关闭资源</h4><h4 id="建议-23：使用-else-子句简化循环（异常处理）"><a href="#建议-23：使用-else-子句简化循环（异常处理）" class="headerlink" title="建议 23：使用 else 子句简化循环（异常处理）"></a>建议 23：使用 else 子句简化循环（异常处理）</h4><h4 id="建议-24：遵循异常处理的几点基本原则"><a href="#建议-24：遵循异常处理的几点基本原则" class="headerlink" title="建议 24：遵循异常处理的几点基本原则"></a>建议 24：遵循异常处理的几点基本原则</h4><p>注意异常的粒度，不推荐在 try 中放入过多的代码。<br>谨慎使用单独的 except 语句处理所有异常，最好能定位具体的异常。<br>注意异常捕获的顺序，在合适的层次处理异常。<br>用户也可以继承自内建异常构建自己的异常类，从而在内建类的继承结构上进一步延伸。<br>使用更为友好的异常信息，遵守异常参数的规范。</p><h4 id="建议-25：避免-finally-中可能发生的陷阱"><a href="#建议-25：避免-finally-中可能发生的陷阱" class="headerlink" title="建议 25：避免 finally 中可能发生的陷阱"></a>建议 25：避免 finally 中可能发生的陷阱</h4><h4 id="建议-26：深入理解-None，正确判断对象是否为空"><a href="#建议-26：深入理解-None，正确判断对象是否为空" class="headerlink" title="建议 26：深入理解 None，正确判断对象是否为空"></a>建议 26：深入理解 None，正确判断对象是否为空</h4><h4 id="建议-27：连接字符串应优先使用-join-而不是"><a href="#建议-27：连接字符串应优先使用-join-而不是" class="headerlink" title="建议 27：连接字符串应优先使用 join 而不是 +"></a>建议 27：连接字符串应优先使用 join 而不是 +</h4><h4 id="建议-28：格式化字符串时尽量使用-format-方式而不是"><a href="#建议-28：格式化字符串时尽量使用-format-方式而不是" class="headerlink" title="建议 28：格式化字符串时尽量使用 .format 方式而不是 %"></a>建议 28：格式化字符串时尽量使用 .format 方式而不是 %</h4><h4 id="建议-29：区别对待可变对象和不可变对象"><a href="#建议-29：区别对待可变对象和不可变对象" class="headerlink" title="建议 29：区别对待可变对象和不可变对象"></a>建议 29：区别对待可变对象和不可变对象</h4><h4 id="建议-30：-、-和-：一致的容器初始化形式"><a href="#建议-30：-、-和-：一致的容器初始化形式" class="headerlink" title="建议 30：[]、() 和 {}：一致的容器初始化形式"></a>建议 30：[]、() 和 {}：一致的容器初始化形式</h4><h4 id="建议-31：记住函数传参既不是传值也不是传引用"><a href="#建议-31：记住函数传参既不是传值也不是传引用" class="headerlink" title="建议 31：记住函数传参既不是传值也不是传引用"></a>建议 31：记住函数传参既不是传值也不是传引用</h4><h4 id="建议-32：警惕默认参数潜在的问题"><a href="#建议-32：警惕默认参数潜在的问题" class="headerlink" title="建议 32：警惕默认参数潜在的问题"></a>建议 32：警惕默认参数潜在的问题</h4><h4 id="建议-33：慎用变长参数"><a href="#建议-33：慎用变长参数" class="headerlink" title="建议 33：慎用变长参数"></a>建议 33：慎用变长参数</h4><h4 id="建议-34：深入理解-str-和-repr-的区别"><a href="#建议-34：深入理解-str-和-repr-的区别" class="headerlink" title="建议 34：深入理解 str() 和 repr() 的区别"></a>建议 34：深入理解 str() 和 repr() 的区别</h4><h4 id="建议-35：分清-staticmethod-和-classmethod-的适用场景"><a href="#建议-35：分清-staticmethod-和-classmethod-的适用场景" class="headerlink" title="建议 35：分清 staticmethod 和 classmethod 的适用场景"></a>建议 35：分清 staticmethod 和 classmethod 的适用场景</h4><h4 id="建议-36：掌握字符串的基本用法"><a href="#建议-36：掌握字符串的基本用法" class="headerlink" title="建议 36：掌握字符串的基本用法"></a>建议 36：掌握字符串的基本用法</h4><h4 id="建议-37：按需选择-sort-或者-sorted"><a href="#建议-37：按需选择-sort-或者-sorted" class="headerlink" title="建议 37：按需选择 sort() 或者 sorted()"></a>建议 37：按需选择 sort() 或者 sorted()</h4><h4 id="建议-38：使用-copy-模块深拷贝对象"><a href="#建议-38：使用-copy-模块深拷贝对象" class="headerlink" title="建议 38：使用 copy 模块深拷贝对象"></a>建议 38：使用 copy 模块深拷贝对象</h4><h4 id="建议-39：使用-Counter-进行计数统计"><a href="#建议-39：使用-Counter-进行计数统计" class="headerlink" title="建议 39：使用 Counter 进行计数统计"></a>建议 39：使用 Counter 进行计数统计</h4><h4 id="建议-40：深入掌握-ConfigParser"><a href="#建议-40：深入掌握-ConfigParser" class="headerlink" title="建议 40：深入掌握 ConfigParser"></a>建议 40：深入掌握 ConfigParser</h4><h4 id="建议-41：使用-argparse-处理命令行参数"><a href="#建议-41：使用-argparse-处理命令行参数" class="headerlink" title="建议 41：使用 argparse 处理命令行参数"></a>建议 41：使用 argparse 处理命令行参数</h4><h4 id="建议-42：使用-pandas-处理大型-CSV-文件"><a href="#建议-42：使用-pandas-处理大型-CSV-文件" class="headerlink" title="建议 42：使用 pandas 处理大型 CSV 文件"></a>建议 42：使用 pandas 处理大型 CSV 文件</h4><h4 id="建议-43：一般情况使用-ElementTree-解析-XML"><a href="#建议-43：一般情况使用-ElementTree-解析-XML" class="headerlink" title="建议 43：一般情况使用 ElementTree 解析 XML"></a>建议 43：一般情况使用 ElementTree 解析 XML</h4><h4 id="建议-44：理解模块-pickle-优劣"><a href="#建议-44：理解模块-pickle-优劣" class="headerlink" title="建议 44：理解模块 pickle 优劣"></a>建议 44：理解模块 pickle 优劣</h4><h4 id="建议-45：序列化的另一个不错的选择——JSON"><a href="#建议-45：序列化的另一个不错的选择——JSON" class="headerlink" title="建议 45：序列化的另一个不错的选择——JSON"></a>建议 45：序列化的另一个不错的选择——JSON</h4><h4 id="建议-46：使用-traceback-获取栈信息"><a href="#建议-46：使用-traceback-获取栈信息" class="headerlink" title="建议 46：使用 traceback 获取栈信息"></a>建议 46：使用 traceback 获取栈信息</h4><h4 id="建议-47：使用-logging-记录日志信息"><a href="#建议-47：使用-logging-记录日志信息" class="headerlink" title="建议 47：使用 logging 记录日志信息"></a>建议 47：使用 logging 记录日志信息</h4><h4 id="建议-48：使用-threading-模块编写多线程程序"><a href="#建议-48：使用-threading-模块编写多线程程序" class="headerlink" title="建议 48：使用 threading 模块编写多线程程序"></a>建议 48：使用 threading 模块编写多线程程序</h4><h4 id="建议-49：使用-Queue-使多线程编程更安全"><a href="#建议-49：使用-Queue-使多线程编程更安全" class="headerlink" title="建议 49：使用 Queue 使多线程编程更安全"></a>建议 49：使用 Queue 使多线程编程更安全</h4><h4 id="建议-50：利用模块实现单例模式"><a href="#建议-50：利用模块实现单例模式" class="headerlink" title="建议 50：利用模块实现单例模式"></a>建议 50：利用模块实现单例模式</h4><h4 id="建议-51：用-mixin-模式让程序更加灵活"><a href="#建议-51：用-mixin-模式让程序更加灵活" class="headerlink" title="建议 51：用 mixin 模式让程序更加灵活"></a>建议 51：用 mixin 模式让程序更加灵活</h4><h4 id="建议-52：用发布订阅模式实现松耦合"><a href="#建议-52：用发布订阅模式实现松耦合" class="headerlink" title="建议 52：用发布订阅模式实现松耦合"></a>建议 52：用发布订阅模式实现松耦合</h4><h4 id="建议-53：用状态模式美化代码"><a href="#建议-53：用状态模式美化代码" class="headerlink" title="建议 53：用状态模式美化代码"></a>建议 53：用状态模式美化代码</h4><h4 id="建议-54：理解-built-in-objects"><a href="#建议-54：理解-built-in-objects" class="headerlink" title="建议 54：理解 built-in objects"></a>建议 54：理解 built-in objects</h4><h4 id="建议-55：init-不是构造方法"><a href="#建议-55：init-不是构造方法" class="headerlink" title="建议 55：init() 不是构造方法"></a>建议 55：<strong>init</strong>() 不是构造方法</h4><h4 id="建议-56：理解名字查找机制"><a href="#建议-56：理解名字查找机制" class="headerlink" title="建议 56：理解名字查找机制"></a>建议 56：理解名字查找机制</h4><h4 id="建议-57：为什么需要-self-参数"><a href="#建议-57：为什么需要-self-参数" class="headerlink" title="建议 57：为什么需要 self 参数"></a>建议 57：为什么需要 self 参数</h4><h4 id="建议-58：理解-MRO-与多继承"><a href="#建议-58：理解-MRO-与多继承" class="headerlink" title="建议 58：理解 MRO 与多继承"></a>建议 58：理解 MRO 与多继承</h4><h4 id="建议-59：理解描述符机制"><a href="#建议-59：理解描述符机制" class="headerlink" title="建议 59：理解描述符机制"></a>建议 59：理解描述符机制</h4><h4 id="建议-60：区别-getattr-和-getattribute-方法"><a href="#建议-60：区别-getattr-和-getattribute-方法" class="headerlink" title="建议 60：区别 getattr() 和 getattribute() 方法"></a>建议 60：区别 <strong>getattr</strong>() 和 <strong>getattribute</strong>() 方法</h4><h4 id="建议-61：使用更为安全的-property"><a href="#建议-61：使用更为安全的-property" class="headerlink" title="建议 61：使用更为安全的 property"></a>建议 61：使用更为安全的 property</h4><h4 id="建议-62：掌握-metaclass"><a href="#建议-62：掌握-metaclass" class="headerlink" title="建议 62：掌握 metaclass"></a>建议 62：掌握 metaclass</h4><h4 id="建议-63：熟悉-Python-对象协议"><a href="#建议-63：熟悉-Python-对象协议" class="headerlink" title="建议 63：熟悉 Python 对象协议"></a>建议 63：熟悉 Python 对象协议</h4><h4 id="建议-64：使用操作符重载实现中缀语法"><a href="#建议-64：使用操作符重载实现中缀语法" class="headerlink" title="建议 64：使用操作符重载实现中缀语法"></a>建议 64：使用操作符重载实现中缀语法</h4><h4 id="建议-65：熟悉-Python-的迭代器协议"><a href="#建议-65：熟悉-Python-的迭代器协议" class="headerlink" title="建议 65：熟悉 Python 的迭代器协议"></a>建议 65：熟悉 Python 的迭代器协议</h4><h4 id="建议-66：熟悉-Python-的生成器"><a href="#建议-66：熟悉-Python-的生成器" class="headerlink" title="建议 66：熟悉 Python 的生成器"></a>建议 66：熟悉 Python 的生成器</h4><h4 id="建议-67：基于生成器的协程及-greenlet"><a href="#建议-67：基于生成器的协程及-greenlet" class="headerlink" title="建议 67：基于生成器的协程及 greenlet"></a>建议 67：基于生成器的协程及 greenlet</h4><h4 id="建议-68：理解-GIL-的局限性"><a href="#建议-68：理解-GIL-的局限性" class="headerlink" title="建议 68：理解 GIL 的局限性"></a>建议 68：理解 GIL 的局限性</h4><h4 id="建议-69：对象的管理与垃圾回收"><a href="#建议-69：对象的管理与垃圾回收" class="headerlink" title="建议 69：对象的管理与垃圾回收"></a>建议 69：对象的管理与垃圾回收</h4><h4 id="建议-70：从-PyPI-安装包"><a href="#建议-70：从-PyPI-安装包" class="headerlink" title="建议 70：从 PyPI 安装包"></a>建议 70：从 PyPI 安装包</h4><h4 id="建议-71：使用-pip-和-yolk-安装、管理包"><a href="#建议-71：使用-pip-和-yolk-安装、管理包" class="headerlink" title="建议 71：使用 pip 和 yolk 安装、管理包"></a>建议 71：使用 pip 和 yolk 安装、管理包</h4><h4 id="建议-72：做-paster-创建包"><a href="#建议-72：做-paster-创建包" class="headerlink" title="建议 72：做 paster 创建包"></a>建议 72：做 paster 创建包</h4><h4 id="建议-73：理解单元测试概念"><a href="#建议-73：理解单元测试概念" class="headerlink" title="建议 73：理解单元测试概念"></a>建议 73：理解单元测试概念</h4><h4 id="建议-74：为包编写单元测试"><a href="#建议-74：为包编写单元测试" class="headerlink" title="建议 74：为包编写单元测试"></a>建议 74：为包编写单元测试</h4><h4 id="建议-75：利用测试驱动开发提高代码的可测性"><a href="#建议-75：利用测试驱动开发提高代码的可测性" class="headerlink" title="建议 75：利用测试驱动开发提高代码的可测性"></a>建议 75：利用测试驱动开发提高代码的可测性</h4><h4 id="建议-76：使用-Pylint-检查代码风格"><a href="#建议-76：使用-Pylint-检查代码风格" class="headerlink" title="建议 76：使用 Pylint 检查代码风格"></a>建议 76：使用 Pylint 检查代码风格</h4><h4 id="建议-77：进行高效的代码审查"><a href="#建议-77：进行高效的代码审查" class="headerlink" title="建议 77：进行高效的代码审查"></a>建议 77：进行高效的代码审查</h4><h4 id="建议-78：将包发布到-PyPI"><a href="#建议-78：将包发布到-PyPI" class="headerlink" title="建议 78：将包发布到 PyPI"></a>建议 78：将包发布到 PyPI</h4><h4 id="建议-79：了解代码优化的基本原则"><a href="#建议-79：了解代码优化的基本原则" class="headerlink" title="建议 79：了解代码优化的基本原则"></a>建议 79：了解代码优化的基本原则</h4><h4 id="建议-80：借助性能优化工具"><a href="#建议-80：借助性能优化工具" class="headerlink" title="建议 80：借助性能优化工具"></a>建议 80：借助性能优化工具</h4><h4 id="建议-81：利用-cProfile-定位性能瓶颈"><a href="#建议-81：利用-cProfile-定位性能瓶颈" class="headerlink" title="建议 81：利用 cProfile 定位性能瓶颈"></a>建议 81：利用 cProfile 定位性能瓶颈</h4><h4 id="建议-82：使用-memory-profiler-和-objgraph-剖析内存使用"><a href="#建议-82：使用-memory-profiler-和-objgraph-剖析内存使用" class="headerlink" title="建议 82：使用 memory_profiler 和 objgraph 剖析内存使用"></a>建议 82：使用 memory_profiler 和 objgraph 剖析内存使用</h4><h4 id="建议-83：努力降低算法复杂度"><a href="#建议-83：努力降低算法复杂度" class="headerlink" title="建议 83：努力降低算法复杂度"></a>建议 83：努力降低算法复杂度</h4><h4 id="建议-84：掌握循环优化的基本技巧"><a href="#建议-84：掌握循环优化的基本技巧" class="headerlink" title="建议 84：掌握循环优化的基本技巧"></a>建议 84：掌握循环优化的基本技巧</h4><h4 id="建议-85：使用生成器提高效率"><a href="#建议-85：使用生成器提高效率" class="headerlink" title="建议 85：使用生成器提高效率"></a>建议 85：使用生成器提高效率</h4><h4 id="建议-86：使用不同的数据结构优化性能"><a href="#建议-86：使用不同的数据结构优化性能" class="headerlink" title="建议 86：使用不同的数据结构优化性能"></a>建议 86：使用不同的数据结构优化性能</h4><h4 id="建议-87：充分利用-set-的优势"><a href="#建议-87：充分利用-set-的优势" class="headerlink" title="建议 87：充分利用 set 的优势"></a>建议 87：充分利用 set 的优势</h4><h4 id="建议-88：使用-multiprocess-克服-GIL-的缺陷"><a href="#建议-88：使用-multiprocess-克服-GIL-的缺陷" class="headerlink" title="建议 88：使用 multiprocess 克服 GIL 的缺陷"></a>建议 88：使用 multiprocess 克服 GIL 的缺陷</h4><h4 id="建议-89：使用线程池提高效率"><a href="#建议-89：使用线程池提高效率" class="headerlink" title="建议 89：使用线程池提高效率"></a>建议 89：使用线程池提高效率</h4><h4 id="建议-90：使用-C-x2F-C-模块扩展高性能"><a href="#建议-90：使用-C-x2F-C-模块扩展高性能" class="headerlink" title="建议 90：使用 C/C++ 模块扩展高性能"></a>建议 90：使用 C/C++ 模块扩展高性能</h4><h4 id="建议-91：使用-Cython-编写扩展模块"><a href="#建议-91：使用-Cython-编写扩展模块" class="headerlink" title="建议 91：使用 Cython 编写扩展模块"></a>建议 91：使用 Cython 编写扩展模块</h4>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++函数返回多值</title>
      <link href="/2022/12/12/c-han-shu-fan-hui-duo-zhi-zong-jie/"/>
      <url>/2022/12/12/c-han-shu-fan-hui-duo-zhi-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>用惯了Python，才发现c++函数默认是返回一个值/无返回值…<br>但是这怎么能难道聪明的工程师们，下面总结几个c++常用的返回多值办法，std::pair在此不讨论，因为他只能返回两个值…</p><p><a href="https://blog.csdn.net/qq_43685921/article/details/123854007">C++函数返回多个值：结构体、tuple</a><br><a href="https://www.geeksforgeeks.org/returning-multiple-values-from-a-function-using-tuple-and-pair-in-c/">Returning multiple values from a function using Tuple and Pair in C++</a></p><h3 id="使用tuple返回多个值"><a href="#使用tuple返回多个值" class="headerlink" title="使用tuple返回多个值"></a>使用tuple返回多个值</h3><p>相比于结构体，要实现函数返回多个值的方法，使用tuple更为简洁、灵活。<br>实现步骤：<br>1.定义函数f(x):类型为tuple<br>2.函数返回多个值:使用make_tuple(result1,result2,…)<br>3.使用函数结果：result=f(x)<br>4.取函数返回值：result1=get&lt;0&gt;(result)； result2=get&lt;1&gt;(result);</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">tuple&lt;<span class="type">int</span>, <span class="type">float</span>&gt;  <span class="title">filterFloorPoint</span><span class="params">( <span class="type">int</span> max_iterations,<span class="type">float</span> in_floor_max_angle,<span class="type">float</span> Distance_Threshold)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> result_iterations;</span><br><span class="line">    <span class="type">float</span> result_angle_add_distance;</span><br><span class="line">    result_iterations=max_iterations*<span class="number">100</span>;</span><br><span class="line">    result_angle_add_distance=in_floor_max_angle*Distance_Threshold;</span><br><span class="line">    <span class="comment">//此时，我们想要函数返回result_iterations和result_angle_add_distance两个值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用make_tuple将要返回的数据写在()里面即可，注意数据类型的顺序</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_tuple</span>(result_iterations,result_angle_add_distance); </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">int</span> max_iterations=<span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> in_floor_max_angle=<span class="number">10.0</span>;</span><br><span class="line"><span class="type">float</span> Distance_Threshold=<span class="number">10.0</span>;</span><br><span class="line"></span><br><span class="line">tuple&lt;<span class="type">int</span>, <span class="type">float</span>&gt;  get_filterFloorPoint_result;</span><br><span class="line"> <span class="comment">//调用 filterFloorPoint 方法</span></span><br><span class="line">get_filterFloorPoint_result=<span class="built_in">filterFloorPoint</span>(max_iterations,in_floor_max_angle,Distance_Threshold);</span><br><span class="line">without_floor_cloud_ptr=<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(get_filterFloorPoint_result); <span class="comment">//取第一个值</span></span><br><span class="line">only_floor_cloud_ptr=<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(get_filterFloorPoint_result);  <span class="comment">//取第二个值</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>另一个例子(对比pair和tuple)</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// A Method that returns multiple values using</span></span><br><span class="line"><span class="comment">// tuple in C++.</span></span><br><span class="line"><span class="function">tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">char</span>&gt; <span class="title">foo</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// Packing values to return a tuple</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_tuple</span>(n2, n1, <span class="string">'a'</span>);             </span><br><span class="line">}</span><br><span class="line">  </span><br><span class="line"><span class="comment">// A Method returns a pair of values using pair</span></span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">foo1</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// Packing two values to return a pair </span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(num2, num1);            </span><br><span class="line">}</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="type">char</span> cc;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// Unpack the elements returned by foo</span></span><br><span class="line">    <span class="built_in">tie</span>(a, b, cc) = <span class="built_in">foo</span>(<span class="number">5</span>, <span class="number">10</span>);      </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// Storing  returned values in a pair </span></span><br><span class="line">    pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p = <span class="built_in">foo1</span>(<span class="number">5</span>,<span class="number">2</span>);  </span><br><span class="line">      </span><br><span class="line">    cout &lt;&lt; <span class="string">"Values returned by tuple: "</span>;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">" "</span> &lt;&lt; b &lt;&lt; <span class="string">" "</span> &lt;&lt; cc &lt;&lt; endl;</span><br><span class="line">      </span><br><span class="line">    cout &lt;&lt; <span class="string">"Values returned by Pair: "</span>;</span><br><span class="line">    cout &lt;&lt; p.first &lt;&lt; <span class="string">" "</span> &lt;&lt; p.second;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其中，<code>#include&lt;bits/stdc++.h&gt;</code> 是一个万能头文件，包含了绝大多数常用的头文件！</p><h3 id="使用结构体返回多个值"><a href="#使用结构体返回多个值" class="headerlink" title="使用结构体返回多个值"></a>使用结构体返回多个值</h3><p>实现步骤：<br>1.先定义一个结构体<br>2.准备我们要实现的函数(需要返回多个值)<br>3.在要实现的函数内调用结构体返回多个值<br>4.使用函数返回结果</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">step <span class="number">1</span> :定义结构体 </span><br><span class="line"><span class="keyword">struct</span>  <span class="title class_">PointStruct</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">float</span> without_floor;</span><br><span class="line">    <span class="type">int</span> only_floor;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">step <span class="number">2</span> :定义函数 </span><br><span class="line"><span class="comment">//定义了一个返回值为PointStruct的函数，函数名为filterFloorPoint</span></span><br><span class="line"><span class="function">PointStruct <span class="title">filterFloorPoint</span><span class="params">( <span class="type">int</span> max_iterations,<span class="type">float</span> in_floor_max_angle,<span class="type">float</span> Distance_Threshold)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> result_iterations;</span><br><span class="line">    <span class="type">float</span> result_angle_add_distance;</span><br><span class="line">    result_iterations=max_iterations*<span class="number">100</span>;</span><br><span class="line">    result_angle_add_distance=in_floor_max_angle*Distance_Threshold;</span><br><span class="line">    <span class="comment">//此时，我们想要函数返回result_iterations和result_angle_add_distance两个值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//step 3:调用结构体返回多个值 </span></span><br><span class="line">    <span class="comment">//调用PointStruct结构体返回多个值 </span></span><br><span class="line">    PointStruct use_PointStruct;  <span class="comment">//use_PointStruct 可以换成你自己想要的名称</span></span><br><span class="line">    use_PointStruct.without_floor=result_iterations;</span><br><span class="line">    use_PointStruct.only_floor=result_angle_add_distance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> use_PointStruct; <span class="comment">//只需要返回 use_PointStruct即可</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"> <span class="comment">//step 4:调用结构体返回的多个值</span></span><br><span class="line"><span class="type">int</span> max_iterations=<span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> in_floor_max_angle=<span class="number">10.0</span>;</span><br><span class="line"><span class="type">float</span> Distance_Threshold=<span class="number">10.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> without_floor_cloud_ptr;</span><br><span class="line"><span class="type">float</span> only_floor_cloud_ptr;  </span><br><span class="line">PointStruct  use_PointStruct_now; <span class="comment">//调用PointStruct结构体</span></span><br><span class="line"></span><br><span class="line"> use_PointStruct_now=<span class="built_in">filterFloorPoint</span>(max_iterations,in_floor_max_angle,Distance_Threshold); <span class="comment">//调用函数</span></span><br><span class="line"> without_floor_cloud_ptr=use_PointStruct_now.without_floor; <span class="comment">//取第一个函数返回值</span></span><br><span class="line"> only_floor_cloud_ptr=use_PointStruct_now.only_floor;<span class="comment">//取第二个函数返回值</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使Python运行更快</title>
      <link href="/2022/12/12/ru-he-shi-python-yun-xing-geng-kuai/"/>
      <url>/2022/12/12/ru-he-shi-python-yun-xing-geng-kuai/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/267531379">ref</a></p><h3 id="避免全局变量-记得使用main函数"><a href="#避免全局变量-记得使用main函数" class="headerlink" title="避免全局变量 (记得使用main函数)"></a>避免全局变量 (记得使用main函数)</h3><p>这种写法耗时5.35s</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">time_start=time.time()</span><br><span class="line">size = <span class="number">5000</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">        z = math.sqrt(x) + math.sqrt(y)</span><br><span class="line"></span><br><span class="line">time_end=time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'time cost'</span>,time_end-time_start,<span class="string">'s'</span>)</span><br></pre></td></tr></tbody></table></figure><p>许多程序员刚开始会用 Python 语言写一些简单的脚本，当编写脚本时，通常习惯了直接将其写为全局变量，例如上面的代码。但是，由于全局变量和局部变量实现方式不同，定义在全局范围内的代码运行速度会比定义在函数中的慢不少。通过将脚本语句放入到函数中，通常可带来 15% - 30% 的速度提升。</p><p>这种写法耗时4.83s</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():  <span class="comment"># 定义到函数中，以减少全部变量使用</span></span><br><span class="line">    size = <span class="number">5000</span></span><br><span class="line">    time_start=time.time()</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            z = math.sqrt(x) + math.sqrt(y)</span><br><span class="line">    </span><br><span class="line">    time_end=time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'time cost'</span>,time_end-time_start,<span class="string">'s'</span>)</span><br><span class="line">    </span><br><span class="line">main()</span><br></pre></td></tr></tbody></table></figure><h3 id="避免-（属性访问操作符）"><a href="#避免-（属性访问操作符）" class="headerlink" title="避免.（属性访问操作符）"></a>避免.（属性访问操作符）</h3><h4 id="避免模块和函数属性访问"><a href="#避免模块和函数属性访问" class="headerlink" title="避免模块和函数属性访问"></a>避免模块和函数属性访问</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不推荐写法。代码耗时3.20s</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">computeSqrt</span>(<span class="params">size: <span class="built_in">int</span></span>):</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">        result.append(math.sqrt(i))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    size = <span class="number">10000</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">        result = computeSqrt(size)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></tbody></table></figure><p>上面的代码有几个问题：</p><ol><li>每次使用.（属性访问操作符时）会触发特定的方法，如__getattribute__()和__getattr__()，这些方法会进行字典操作，因此会带来额外的时间开销。通过from import语句，可以消除属性访问</li><li>局部变量的查找会比全局变量更快，因此对于频繁访问的变量sqrt，通过将其改为局部变量可以加速运行</li><li>除了math.sqrt外，computeSqrt函数中还有.的存在，那就是调用list的append方法。通过将该方法赋值给一个局部变量，可以彻底消除computeSqrt函数中for循环内部的.使用。</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 推荐写法。代码耗时1.98s</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">computeSqrt</span>(<span class="params">size: <span class="built_in">int</span></span>):</span><br><span class="line">    result = []</span><br><span class="line">    append = result.append</span><br><span class="line">    sqrt = math.sqrt    <span class="comment"># 赋值给局部变量</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">        append(sqrt(i))  <span class="comment"># 避免 result.append 和 math.sqrt 的使用</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    size = <span class="number">10000</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">        result = computeSqrt(size)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></tbody></table></figure><h4 id="避免类内属性访问"><a href="#避免类内属性访问" class="headerlink" title="避免类内属性访问"></a>避免类内属性访问</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不推荐写法。代码耗时：10.4秒</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value: <span class="built_in">int</span></span>):</span><br><span class="line">        self._value = value</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">computeSqrt</span>(<span class="params">self, size: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]:</span><br><span class="line">        result = []</span><br><span class="line">        append = result.append</span><br><span class="line">        sqrt = math.sqrt</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            append(sqrt(self._value))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    size = <span class="number">10000</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">        demo_instance = DemoClass(size)</span><br><span class="line">        result = demo_instance.computeSqrt(size)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></tbody></table></figure><p>避免.的原则也适用于类内属性，访问self._value的速度会比访问一个局部变量更慢一些。通过将需要频繁访问的类内属性赋值给一个局部变量，可以提升代码运行速度。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 推荐写法。代码耗时：8.0秒</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value: <span class="built_in">int</span></span>):</span><br><span class="line">        self._value = value</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">computeSqrt</span>(<span class="params">self, size: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]:</span><br><span class="line">        result = []</span><br><span class="line">        append = result.append</span><br><span class="line">        sqrt = math.sqrt</span><br><span class="line">        value = self._value</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            append(sqrt(value))  <span class="comment"># 避免 self._value 的使用</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    size = <span class="number">10000</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">        demo_instance = DemoClass(size)</span><br><span class="line">        demo_instance.computeSqrt(size)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></tbody></table></figure><h3 id="避免数据复制"><a href="#避免数据复制" class="headerlink" title="避免数据复制"></a>避免数据复制</h3><h4 id="避免无意义的数据复制"><a href="#避免无意义的数据复制" class="headerlink" title="避免无意义的数据复制"></a>避免无意义的数据复制</h4><h4 id="交换值时不使用中间变量"><a href="#交换值时不使用中间变量" class="headerlink" title="交换值时不使用中间变量"></a>交换值时不使用中间变量</h4><p>有些代码在交换值时创建了一个临时变量temp，如果不借助中间变量，代码更为简洁、且运行速度更快。</p><h4 id="字符串拼接用join而不是"><a href="#字符串拼接用join而不是" class="headerlink" title="字符串拼接用join而不是+"></a>字符串拼接用join而不是+</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不推荐写法，代码耗时：2.6秒</span></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">concatString</span>(<span class="params">string_list: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    result = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> str_i <span class="keyword">in</span> string_list:</span><br><span class="line">        result += str_i</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    string_list = <span class="built_in">list</span>(string.ascii_letters * <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line">        result = concatString(string_list)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></tbody></table></figure><p>当使用a + b拼接字符串时，由于 Python 中字符串是不可变对象，其会申请一块内存空间，将a和b分别复制到该新申请的内存空间中。而使用join()拼接字符串时，会首先计算出需要申请的总的内存空间，然后一次性地申请所需内存，并将每个字符串元素复制到该内存中去。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 推荐写法，代码耗时：0.3秒</span></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">concatString</span>(<span class="params">string_list: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(string_list)  <span class="comment"># 使用 join 而不是 +</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    string_list = <span class="built_in">list</span>(string.ascii_letters * <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line">        result = concatString(string_list)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></tbody></table></figure><h4 id="利用if条件的短路特性"><a href="#利用if条件的短路特性" class="headerlink" title="利用if条件的短路特性"></a>利用if条件的短路特性</h4><p>if 条件的短路特性是指对if a and b这样的语句， 当a为False时将直接返回，不再计算b；对于if a or b这样的语句，当a为True时将直接返回，不再计算b。因此， 为了节约运行时间，对于or语句，应该将值为True可能性比较高的变量写在or前，而and应该推后。</p><h3 id="循环优化"><a href="#循环优化" class="headerlink" title="循环优化"></a>循环优化</h3><h4 id="用for循环代替while循环"><a href="#用for循环代替while循环" class="headerlink" title="用for循环代替while循环"></a>用for循环代替while循环</h4><h4 id="使用隐式for循环代替显式for循环"><a href="#使用隐式for循环代替显式for循环" class="headerlink" title="使用隐式for循环代替显式for循环"></a>使用隐式for循环代替显式for循环</h4><h4 id="减少内层for循环的计算"><a href="#减少内层for循环的计算" class="headerlink" title="减少内层for循环的计算"></a>减少内层for循环的计算</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不推荐写法。代码耗时：12.8秒</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    size = <span class="number">10000</span></span><br><span class="line">    sqrt = math.sqrt</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            z = sqrt(x) + sqrt(y)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></tbody></table></figure><p>上面的代码中sqrt(x)位于内侧for循环， 每次训练过程中都会重新计算一次，增加了时间开销。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 推荐写法。代码耗时：7.0秒</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    size = <span class="number">10000</span></span><br><span class="line">    sqrt = math.sqrt</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">        sqrt_x = sqrt(x)  <span class="comment"># 减少内层 for 循环的计算</span></span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            z = sqrt_x + sqrt(y)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></tbody></table></figure><h3 id="选择合适的数据结构"><a href="#选择合适的数据结构" class="headerlink" title="选择合适的数据结构"></a>选择合适的数据结构</h3><p>Python 内置的数据结构如str, tuple, list, set, dict底层都是 C 实现的，速度非常快，自己实现新的数据结构想在性能上达到内置的速度几乎是不可能的。</p><p>list类似于 C++ 中的std::vector，是一种动态数组。其会预分配一定内存空间，当预分配的内存空间用完，又继续向其中添加元素时，会申请一块更大的内存空间，然后将原有的所有元素都复制过去，之后销毁之前的内存空间，再插入新元素。删除元素时操作类似，当已使用内存空间比预分配内存空间的一半还少时，会另外申请一块小内存，做一次元素复制，之后销毁原有大内存空间。因此，如果有频繁的新增、删除操作，新增、删除的元素数量又很多时，list的效率不高。此时，应该考虑使用collections.deque。collections.deque是双端队列，同时具备栈和队列的特性，能够在两端进行 复杂度的插入和删除操作。</p><p>list的查找操作也非常耗时。当需要在list频繁查找某些元素，或频繁有序访问这些元素时，可以使用bisect维护list对象有序并在其中进行二分查找，提升查找的效率。</p><p>另外一个常见需求是查找极小值或极大值，此时可以使用heapq模块将list转化为一个堆，使得获取最小值的时间复杂度是 。</p><p><a href="https://zhuanlan.zhihu.com/p/267531379">ref</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google开源项目风格指南——Python风格规范</title>
      <link href="/2022/12/08/python-feng-ge-gui-fan/"/>
      <url>/2022/12/08/python-feng-ge-gui-fan/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/contents/">Python风格指南(中文版)</a></p><h3 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h3><p>如果你先学习了c++，记得不要在行尾加分号，也不要用分号将两条命令放在同一行</p><h3 id="行长度"><a href="#行长度" class="headerlink" title="行长度"></a>行长度</h3><p>每行不超过80个字符。<br>但是：url/路径等不要分割</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Yes: foo_bar(self, width, height, color=<span class="string">'black'</span>, design=<span class="literal">None</span>, x=<span class="string">'foo'</span>,</span><br><span class="line">             emphasis=<span class="literal">None</span>, highlight=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (width == <span class="number">0</span> <span class="keyword">and</span> height == <span class="number">0</span> <span class="keyword">and</span></span><br><span class="line">         color == <span class="string">'red'</span> <span class="keyword">and</span> emphasis == <span class="string">'strong'</span>):</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Yes:  <span class="comment"># See details at</span></span><br><span class="line">      <span class="comment"># http://www.example.com/us/developer/documentation/api/content/v2.0/csv_file_name_extension_full_specification.html</span></span><br><span class="line"></span><br><span class="line">No:  <span class="comment"># See details at</span></span><br><span class="line">     <span class="comment"># http://www.example.com/us/developer/documentation/api/content/\</span></span><br><span class="line">     <span class="comment"># v2.0/csv_file_name_extension_full_specification.html</span></span><br></pre></td></tr></tbody></table></figure><h3 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h3><p><strong>宁缺毋滥</strong></p><h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><p><strong>用4个空格来缩进代码</strong><br>绝对不要用tab, 也不要tab和空格混用. 建议使用4空格的悬挂式缩进</p><h3 id="序列元素尾部逗号"><a href="#序列元素尾部逗号" class="headerlink" title="序列元素尾部逗号"></a>序列元素尾部逗号</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Yes:   golomb3 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">Yes:   golomb4 = [</span><br><span class="line">           <span class="number">0</span>,</span><br><span class="line">           <span class="number">1</span>,</span><br><span class="line">           <span class="number">4</span>,</span><br><span class="line">           <span class="number">6</span>,</span><br><span class="line">       ]</span><br><span class="line"></span><br><span class="line">No:    golomb4 = [</span><br><span class="line">           <span class="number">0</span>,</span><br><span class="line">           <span class="number">1</span>,</span><br><span class="line">           <span class="number">4</span>,</span><br><span class="line">           <span class="number">6</span></span><br><span class="line">       ]</span><br></pre></td></tr></tbody></table></figure><h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h3><p>顶级定义之间空两行, 比如函数或者类定义. 方法定义, 类定义与第一个方法之间, 都应该空一行. 函数或方法中, 某些地方要是你觉得合适, 就空一行.</p><h3 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h3><p>括号内不要有空格<br>不要在逗号, 分号, 冒号前面加空格, 但应该在它们后面加(除了在行尾)<br>参数列表, 索引或切片的左括号前不应加空格<br>……</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>参考《编写可读代码的艺术》</p><h3 id="标点符号-拼写和语法"><a href="#标点符号-拼写和语法" class="headerlink" title="标点符号,拼写和语法"></a>标点符号,拼写和语法</h3><p>注意标点符号,拼写和语法</p><p>注释应有适当的大写和标点,句子应该尽量完整.对于诸如在行尾上的较短注释,可以不那么正式,但是也应该尽量保持风格一致</p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>如果一个类不继承自其它类, 就显式的从object继承. 嵌套类也一样.(除非是为了和 python2 兼容)</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>避免在循环中用+和+=操作符来累加字符串. 由于字符串是不可变的, 这样做会创建不必要的临时对象, 并且导致二次方而不是线性的运行时间. 作为替代方案, 你可以将每个子串加入列表, 然后在循环结束后用 <code>.join</code> 连接列表. (也可以将每个子串写入一个 <code>cStringIO.StringIO</code> 缓存中.)</p><p>为多行字符串使用三重双引号”””而非三重单引号’’’. </p><h3 id="文件和sockets"><a href="#文件和sockets" class="headerlink" title="文件和sockets"></a>文件和sockets</h3><p><strong>在文件和sockets结束时, 显式的关闭它</strong></p><h3 id="TODO注释"><a href="#TODO注释" class="headerlink" title="TODO注释"></a>TODO注释</h3><p>为临时代码使用TODO注释, 它是一种短期解决方案. 不算完美, 但够好了.</p><h3 id="导入格式"><a href="#导入格式" class="headerlink" title="导入格式"></a>导入格式</h3><p>每个导入应该独占一行, <code>typing</code> 的导入除外</p><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>通常每个语句应该独占一行</p><p>不过, 如果测试结果与测试语句在一行放得下, 你也可以将它们放在同一行. 如果是if语句, 只有在没有else时才能这样做</p><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><p>模块名写法: module_name ;<br>包名写法: package_name ;<br>类名: ClassName ;<br>方法名: method_name ;<br>异常名: ExceptionName ;<br>函数名: function_name ;<br>全局常量名: GLOBAL_CONSTANT_NAME ;<br>全局变量名: global_var_name ;<br>实例名: instance_var_name ;<br>函数参数名: function_parameter_name ;<br>局部变量名: local_var_name</p><p>函数名,变量名和文件名应该是描述性的,尽量避免缩写,特别要避免使用非项目人员不清楚难以理解的缩写,不要通过删除单词中的字母来进行缩写. 始终使用 .py 作为文件后缀名,不要用破折号.</p><p>应该避免的名称</p><ul><li>单字符名称, 除了计数器和迭代器,作为 try/except 中异常声明的 e,作为 with 语句中文件句柄的 f.</li><li>包/模块名中的连字符(-)</li><li>双下划线开头并结尾的名称(Python保留, 例如__init__)</li></ul><h3 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h3><p>即使是一个打算被用作脚本的文件, 也应该是可导入的. 并且简单的导入不应该导致这个脚本的主功能(main functionality)被执行, 这是一种副作用. 主功能应该放在一个main()函数中.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure><h3 id="函数长度"><a href="#函数长度" class="headerlink" title="函数长度"></a>函数长度</h3><p>推荐函数功能尽量集中,简单,小巧</p><p>不对函数长度做硬性限制.但是若一个函数超过来40行,推荐考虑一下是否可以在不损害程序结构的情况下对其进行分解. </p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux实用工具</title>
      <link href="/2022/12/07/linux-shi-yong-gong-ju/"/>
      <url>/2022/12/07/linux-shi-yong-gong-ju/</url>
      
        <content type="html"><![CDATA[<h3 id="截图工具"><a href="#截图工具" class="headerlink" title="截图工具"></a>截图工具</h3><p>最好用的当属Kazan和Shutter，前者不仅能截屏还能录屏；后者截屏功能相对更加强大。<br>命令行apt安装即可。</p><h3 id="办公软件"><a href="#办公软件" class="headerlink" title="办公软件"></a>办公软件</h3><p>WPS，支持国产</p><h3 id="远程控制"><a href="#远程控制" class="headerlink" title="远程控制"></a>远程控制</h3><p>用过Google chrome desktop, Teamviewer等一大堆软件，现在表示还是向日(Sunlogin)最好用…</p><h3 id="c-编译软件"><a href="#c-编译软件" class="headerlink" title="c++编译软件"></a>c++编译软件</h3><p>有很多，推荐一款常用的 Bazel</p><h3 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h3><p>用来用去，最好的还是VSCode。此外你也可以尝试Atom</p>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有价值的网站</title>
      <link href="/2022/12/07/you-jie-zhi-de-wang-zhan/"/>
      <url>/2022/12/07/you-jie-zhi-de-wang-zhan/</url>
      
        <content type="html"><![CDATA[<p>本文分为两部分，前半部分主要涉及计算机编程，后半部分涉及机器人学。无论你是想转码的小白，初学的开发者，还是机器人工程师，希望这篇文章都能给你带来新的知识。</p><h2 id="一些CS网站分享"><a href="#一些CS网站分享" class="headerlink" title="一些CS网站分享"></a>一些CS网站分享</h2><h3 id="Google开源项目风格指南-中文版"><a href="#Google开源项目风格指南-中文版" class="headerlink" title="Google开源项目风格指南 (中文版)"></a><a href="https://zh-google-styleguide.readthedocs.io/en/latest/contents/">Google开源项目风格指南</a> (中文版)</h3><p>养成一套良好的代码编写习惯非常重要，无论是对于开发者还是阅读者 <span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><h3 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a><a href="https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/markdown-basics">Markdown</a></h3><p>Markdown写作是制作blog/github的好伙伴。</p><h3 id="about-Mermaid"><a href="#about-Mermaid" class="headerlink" title="about Mermaid"></a><a href="https://mermaid-js.github.io/mermaid/#/README">about Mermaid</a></h3><p>Mermaid用来在Markdown中画图，比如甘特图、流程图等，很好的辅助工具。</p><h3 id="CS自学指南"><a href="#CS自学指南" class="headerlink" title="CS自学指南"></a><a href="https://csdiy.wiki/">CS自学指南</a></h3><p>该作者总结了很多自学cs的方法，有用网课和网站</p><h3 id="CS106L-Standard-C-Programming"><a href="#CS106L-Standard-C-Programming" class="headerlink" title="CS106L: Standard C++ Programming"></a><a href="http://web.stanford.edu/class/cs106l/">CS106L: Standard C++ Programming</a></h3><p>c++的进阶课程，适合有一点编程基础的人学习，能够了解c++更多语法和特性。</p><h3 id="编写高质量代码改善-Python-程序的-91-个建议"><a href="#编写高质量代码改善-Python-程序的-91-个建议" class="headerlink" title="编写高质量代码改善 Python 程序的 91 个建议"></a><a href="https://l1nwatch.gitbook.io/writing_solid_python_code_gitbook/">编写高质量代码改善 Python 程序的 91 个建议</a></h3><p>让你的Python代更专业！</p><h3 id="c-primer-plus习题及笔记"><a href="#c-primer-plus习题及笔记" class="headerlink" title="c++ primer plus习题及笔记"></a><a href="https://github.com/ShujiaHuang/Cpp-Primer-Plus-6th">c++ primer plus习题及笔记</a></h3><h3 id="c-入门教程"><a href="#c-入门教程" class="headerlink" title="c++入门教程"></a><a href="http://c.biancheng.net/cplus/">c++入门教程</a></h3><p>类似菜鸟教程，但是我觉得写的比菜鸟更详细一点，可以当做cheatsheet查阅c++语法。</p><h2 id="一些机器人学网站分享"><a href="#一些机器人学网站分享" class="headerlink" title="一些机器人学网站分享"></a>一些机器人学网站分享</h2><h3 id="机器人工程师成长指南"><a href="#机器人工程师成长指南" class="headerlink" title="机器人工程师成长指南"></a><a href="https://zhuanlan.zhihu.com/p/22266788">机器人工程师成长指南</a></h3><p>教你如何从小白一步步成为优秀的机器人领域开发者</p>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科学上网（2022年12月） 适用于Linux &amp; Windows</title>
      <link href="/2022/12/05/ru-he-ke-xue-shang-wang/"/>
      <url>/2022/12/05/ru-he-ke-xue-shang-wang/</url>
      
        <content type="html"><![CDATA[<p>作为机器人工程师，我们不得不使用stackoverflow，github等网站。</p><p>由于众所周知的原因，我们需要科学上网工具，在此推荐一款便宜好用的梯子，适用于全平台:<br><a href="https://windscribe.com/">Windscribe</a><br>它不仅节点多，速度快，而且便宜。支持按照节点数购买，一个地区的节点一个月仅需一刀。</p><p>如果你的电脑不能打开windscibe官网，可以在<a href="https://github.com/rd-zhang/windscribe_deb">这里</a>下载deb安装包。</p>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《编写可读代码的艺术》(一)</title>
      <link href="/2022/12/02/bian-xie-ke-du-dai-ma-de-yi-zhu-1/"/>
      <url>/2022/12/02/bian-xie-ke-du-dai-ma-de-yi-zhu-1/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>第一次被推荐这本书的时候我已经写了两年代码。尽管自己已经形成了一套命名和注释方法，但是对于代码的可阅读性并没有太过深入的思考。_<a href="https://mcusoft.files.wordpress.com/2015/04/the-art-of-readable-code.pdf">The Art of Readable Code</a>_ (中文译名<a href="https://awesome-programming-books.github.io/clean-code/%E7%BC%96%E5%86%99%E5%8F%AF%E8%AF%BB%E4%BB%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF.pdf">《编写可读代码的艺术》</a>)通过15个章节从简到繁，轻松又愉快的使你明白如何写出‘易于理解’的代码。</p><h3 id="第1章—代码应当易于理解"><a href="#第1章—代码应当易于理解" class="headerlink" title="第1章—代码应当易于理解"></a>第1章—代码应当易于理解</h3><p><strong>代码易于理解</strong> 是关键思想。<br>代码的写法应当使别人理解它所需的时间最小化。但是虽然减少代码行数是一个重要目标，我们的最终目标仍然是把理解代码所需时间最小化。<br>编写代码时要经常站在别的角度，想一想自己写的代码别能否轻松理解。</p><h1 id="Part-1-表明层次的改进"><a href="#Part-1-表明层次的改进" class="headerlink" title="Part 1. 表明层次的改进"></a>Part 1. 表明层次的改进</h1><p>可读性之旅从“表面层次”的改进开始：选择好的名字、写好的注释以及把代码整洁的写成更好的格式。</p><h3 id="第2章—把信息装进名字里"><a href="#第2章—把信息装进名字里" class="headerlink" title="第2章—把信息装进名字里"></a>第2章—把信息装进名字里</h3><p>选择专业的词语：比如fetchPage相比getPage显得更加专业而清晰；<br>避免泛泛的名字: 如tmp，retval。好的名字应当描述变量的目的或者它承载的值，除非你确定你只是临时的用一次tmp;<br>使用具体的名字更细致的描述：<a href="https://blog.csdn.net/fuhanghang/article/details/119805459">这里</a>总结了一些常用的命名方法。个人偏爱使用下划线法命名，把每个变量具体干什么使用起英文短语命名，如 <em>log_finishedinfo_when_reach_terminal</em> ;<br>给变量名加上重要细节：比如JS中的 <em>getTime()</em> 返回单位是毫秒，那么就可以给变量加上 _<em>ms</em> 的后缀;<br>名字的长度：应当遵循作用域越大名字越长的原则，比如一个字母 <em>m</em> 如果作用于全域，读者很可能不知道他是干什么的。这就好比旅行，越长的假期你总是会带越多的行李；<br>有目的使用下划线：你可以在类成员和局部变量后面加上下划线来区分他们。</p><h3 id="第3章—不会误解的名字"><a href="#第3章—不会误解的名字" class="headerlink" title="第3章—不会误解的名字"></a>第3章—不会误解的名字</h3><p><em>Filter()</em> 是一个很好的例子，我的意思是它是一个很糟糕的命名。因为读者根本不知道这个函数是用于 <strong>筛选出</strong> 一部分结果还是 <strong>筛选掉</strong> 一部分结果！<br>而涉及到bool值的时候尽量避免诸如多重否定的文字游戏。比如 <em>is_task_finished</em> 的返回值能够直观的说明任务是否完成了。<br>对于区间的表示，推荐使用一套约定俗成的方法：</p><ul><li>min, max 表示极限</li><li>first, last 表示包含的范围(闭区间)</li><li>begin, end 表示包含的范围(开区间)</li><li>etc…</li></ul><p>总之，你应该三思，别人是否会对命名产生不一样的理解。</p><h3 id="第4章—审美"><a href="#第4章—审美" class="headerlink" title="第4章—审美"></a>第4章—审美</h3><p>好的代码应该看上去遵循 <strong>养眼</strong> ，三条原则：</p><ul><li>使用一致的布局，让读者很快就能习惯这种风格</li><li>让相似的代码看上去相似</li><li>把相关的代码分组，形成代码块</li></ul><p>编程的大部分时间都花在看代码上，浏览代码的速度越快，人们越容易使用它：</p><ul><li>重新安排换行来保持一致和紧凑；</li><li>用方法来整理不规则的东西；</li><li>在需要的时候使用列对齐；</li><li>选择一个有意义的顺序，比如重要性排序，并保持一致的使用它；</li><li>把声明按照块组织起来，按照逻辑分组，添加注释；</li><li>把代码分成段落，比如按照步骤划分；</li><li>个人风格要保证一致性，比如大括号的位置。</li></ul><h3 id="第5章—该写什么样的注释"><a href="#第5章—该写什么样的注释" class="headerlink" title="第5章—该写什么样的注释"></a>第5章—该写什么样的注释</h3><p> 注释的目的是尽量帮助读者了解得和作者一样多：</p><ul><li>不要为那些从代码本身就能快速推断的事实写注释</li><li>不要为了注释而注释</li><li>与其给名字不好的函数写注释，不如把其名字先改好，即 <strong>好代码 &gt; 坏代码 + 好注释</strong></li></ul><p> 应该记录下来的想法包括：</p><ul><li>为什么这个地方代码写成这样而不是别的？</li><li>代码中有缺陷的地方，可以写一个 _TODO: XXX_；</li><li>常量为什么定义这个值？ (比如 <em>length = 10 is big enough to describe the object shape</em> )。</li></ul><p>站在读者的立场上思考：</p><ul><li>预料到那些地方会使读者不解或出乎意料，并加上注释；</li><li>在文件/类的级别上使用“全局观”注释，以解释他们是如何一起工作的</li><li>用注释作为代码块的总结。</li></ul><h3 id="第6章—写出言简意赅的注释"><a href="#第6章—写出言简意赅的注释" class="headerlink" title="第6章—写出言简意赅的注释"></a>第6章—写出言简意赅的注释</h3><p> <strong>注释要有很高的信息率和空间率</strong></p><ul><li>让注释保持紧凑，能写一行的注释不要写三行；</li><li>避免使用不明确的代词，不要用 <em>it</em> 这种模糊词语；</li><li>润色粗糙的句子(这可能考验语文功底…)；</li><li>精确描述函数的行为；</li><li>用输入输出例子来描述特殊的情况(对于工程师来说这无疑更直观)；</li><li>声明代码的意图；</li><li>使用具名函数。python 等语言能这么调用： <em>connect(timeout = 10, use_encryption = False)</em> ；</li><li>采用信息量高的词语；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《编写可读代码的艺术》(二)</title>
      <link href="/2022/12/02/bian-xie-ke-du-dai-ma-de-yi-zhu-2/"/>
      <url>/2022/12/02/bian-xie-ke-du-dai-ma-de-yi-zhu-2/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>第一次被推荐这本书的时候我已经写了两年代码。尽管自己已经形成了一套命名和注释方法，但是对于代码的可阅读性并没有太过深入的思考。_<a href="https://mcusoft.files.wordpress.com/2015/04/the-art-of-readable-code.pdf">The Art of Readable Code</a>_ (中文译名<a href="https://awesome-programming-books.github.io/clean-code/%E7%BC%96%E5%86%99%E5%8F%AF%E8%AF%BB%E4%BB%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF.pdf">《编写可读代码的艺术》</a>)通过15个章节从简到繁，轻松又愉快的使你明白如何写出‘易于理解’的代码。</p><h1 id="Part-2-简化循环和逻辑"><a href="#Part-2-简化循环和逻辑" class="headerlink" title="Part 2. 简化循环和逻辑"></a>Part 2. 简化循环和逻辑</h1><p>这一部分将深入讨论程序的“循环和逻辑”：控制流、逻辑表达式等等。我们将试着最小化代码中的“思维包袱”来达到目的。</p><h3 id="第7章—把控制流变得易读"><a href="#第7章—把控制流变得易读" class="headerlink" title="第7章—把控制流变得易读"></a>第7章—把控制流变得易读</h3><p>条件语句中左右两侧分别是“被询问的”和“用来作比较的标准”，比如 <em>if(length &gt; 10)</em> 看起来就很自然；<br><em>if/else</em> 语句处理顺序：正常逻辑优先，简单逻辑优先，可疑或有趣项优先；<br>对于C语言中的三目表达式，更重要的是减少理解其逻辑的时间，因此要注意代码行数与复杂度之间的平衡；<br>避免 <em>do/while</em> 循环，尽量换成 <em>while</em> 或其他循环；<br>可以在函数中提前 <em>return</em> 返回，但要避免使用臭名昭著的 <em>goto</em> ；<br><strong>最小化嵌套</strong> “故意嵌套很深的代码就是一坨屎” ——图图。你可以通过提前返回来减少嵌套。</p><h3 id="第8章—拆分超长的表达式"><a href="#第8章—拆分超长的表达式" class="headerlink" title="第8章—拆分超长的表达式"></a>第8章—拆分超长的表达式</h3><p>如果你百度一下，可能会发现人脑的容量高达7亿TB。但是其实人脑的RAM非常小，以至于大脑同时只能考虑3~4件事。本章的核心思想是—— <strong>把超长的表达式拆分成更容易理解的小块</strong> 。<br>一个简单的例子件事，把某一行代码拆分为两行。第一行多定义一个变量，即“解释变量”，他能够帮助读者理解这个值是干什么的；<br>你也可以使用一个总结性的变量，比如一个bool值，来解释一些拗口的判断式，并利用 <em>if/else</em> 辅助；<br>使用电路学中的“德摩根定理”，它的核心思想是通过整体取反的方式，在不改变逻辑的情况下使判断式更好理解(即前文提到的避免多重否定)；<br>不要滥用短路逻辑；<br>提取出大量重复的表达式为变量，例如C++中的宏(尽管有时并不建议使用宏，但当它对可读性利大于弊时可以采用)。</p><h3 id="第9章—变量与可读性"><a href="#第9章—变量与可读性" class="headerlink" title="第9章—变量与可读性"></a>第9章—变量与可读性</h3><p>对于变量的草率运用会让程序更难理解：</p><ul><li>变量越多，越难以跟踪他们的动向；</li><li>变量的作用域越大，就需要跟踪它的动向越久；</li><li>变量改变地越频繁，就越难以跟踪它的当前值。</li></ul><p>如何处理：</p><ul><li>减少无价值的临时变量，比如根本就没有必要定义 <em>now = datetime.datetime.now()</em> ，直接使用这个时间函数即可；</li><li>减少控制流变量，避免使用 <em>done</em> 这样的“控制流变量”；</li><li>缩小变量作用域，防止名称污染，让你的变量对尽量少的代码行可见；</li><li>只写一次的变量更好，因为常量往往不会引来麻烦。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《编写可读代码的艺术》(三)</title>
      <link href="/2022/12/02/bian-xie-ke-du-dai-ma-de-yi-zhu-3/"/>
      <url>/2022/12/02/bian-xie-ke-du-dai-ma-de-yi-zhu-3/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>第一次被推荐这本书的时候我已经写了两年代码。尽管自己已经形成了一套命名和注释方法，但是对于代码的可阅读性并没有太过深入的思考。_<a href="https://mcusoft.files.wordpress.com/2015/04/the-art-of-readable-code.pdf">The Art of Readable Code</a>_ (中文译名<a href="https://awesome-programming-books.github.io/clean-code/%E7%BC%96%E5%86%99%E5%8F%AF%E8%AF%BB%E4%BB%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF.pdf">《编写可读代码的艺术》</a>)通过15个章节从简到繁，轻松又愉快的使你明白如何写出‘易于理解’的代码。</p><h1 id="Part-3-重新组织代码"><a href="#Part-3-重新组织代码" class="headerlink" title="Part 3. 重新组织代码"></a>Part 3. 重新组织代码</h1><p>该部分会讨论可以在函数级别对代码做更大的改动。</p><h3 id="第10章—抽取不相关的子问题"><a href="#第10章—抽取不相关的子问题" class="headerlink" title="第10章—抽取不相关的子问题"></a>第10章—抽取不相关的子问题</h3><p><strong>积极地发现并抽取出不相关的子逻辑</strong></p><ul><li>如果足够多行数的代码并不是在解决当前问题，那么把他们放到独立的函数中去；</li><li>你可以自己写一些工具性的代码来填充编程语言中的空白，比如C++中没有简单的方法来读取整个文件，你可以自己写一个 <em>ReadFileToString()</em> 并当做库函数使用；</li><li>创建大量通用代码，这样你代码的其余部分会更小而且容易思考；</li><li>简化已有接口，按需重塑接口；</li><li>最后要记住，避免 <strong>过犹不及</strong> ！</li></ul><h3 id="第11章—一次只做一件事"><a href="#第11章—一次只做一件事" class="headerlink" title="第11章—一次只做一件事"></a>第11章—一次只做一件事</h3><p>把代码组织得一次只做一件事：</p><ul><li>列出代码所做的所有任务，其中一些可以变成独立的函数/类；</li><li>尽力把这些任务拆分到不同的函数中。</li></ul><h3 id="第12章—把想法变成代码"><a href="#第12章—把想法变成代码" class="headerlink" title="第12章—把想法变成代码"></a>第12章—把想法变成代码</h3><p>用自然语言描述程序来帮助写出更自然的代码:</p><ul><li>清楚地描述逻辑；</li><li>了解所使用的编程语言的库函数，比如一些提示框内的建议很有帮助；</li><li>首先把本方法用于小块代码，然后应用于更大的问题。</li></ul><h3 id="第13章—少写代码"><a href="#第13章—少写代码" class="headerlink" title="第13章—少写代码"></a>第13章—少写代码</h3><p><strong>最好读的代码就是没有代码</strong></p><ul><li>别费劲去做你不太需要的功能；</li><li>质疑并拆分你的需求；</li><li>记得思考你的输入和输出是什么，并不是任何时候输入都是很复杂的；</li><li>让你的代码库越小、越轻量级越好；</li><li>熟悉你周边的库，避免重复造轮子。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《编写可读代码的艺术》(四|实战)(完)</title>
      <link href="/2022/12/02/bian-xie-ke-du-dai-ma-de-yi-zhu-4/"/>
      <url>/2022/12/02/bian-xie-ke-du-dai-ma-de-yi-zhu-4/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>第一次被推荐这本书的时候我已经写了两年代码。尽管自己已经形成了一套命名和注释方法，但是对于代码的可阅读性并没有太过深入的思考。_<a href="https://mcusoft.files.wordpress.com/2015/04/the-art-of-readable-code.pdf">The Art of Readable Code</a>_ (中文译名<a href="https://awesome-programming-books.github.io/clean-code/%E7%BC%96%E5%86%99%E5%8F%AF%E8%AF%BB%E4%BB%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF.pdf">《编写可读代码的艺术》</a>)通过15个章节从简到繁，轻松又愉快的使你明白如何写出‘易于理解’的代码。</p><h1 id="Part-4-精选话题"><a href="#Part-4-精选话题" class="headerlink" title="Part 4. 精选话题"></a>Part 4. 精选话题</h1><p>在本书的最后一部分，之前讨论的各种技巧会应用到两个精选的话题中。</p><h3 id="第14章—测试与可读性"><a href="#第14章—测试与可读性" class="headerlink" title="第14章—测试与可读性"></a>第14章—测试与可读性</h3><p><strong>测试应当具有可读性，以便使其他程序员可以舒服的改变或者增加测试</strong><br>记住对使用者隐去不重要的细节，以便更重要的细节会更为突出；<br>大多数的测试都能精炼成“对于xx的输入/情况，期望有xx的输出/行为”；<br><strong>让错误消息具有可读性</strong><br>多用 <em>assert()</em>;<br>手工打造错误消息，选择好的测试输入，又简单又能完成工作的测试值更好；<br>与其建立单个“完美”输入来完整地执行代码，不如写多个小测试，因为他们更具有可读性；<br>为测试函数命名，但是避免“test”这种没什么意义的名字；</p><p>下面我们来看一个例子，在这段代码中</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test1</span><span class="params">()</span></span>{</span><br><span class="line">  vector&lt;ScoredDocument&gt; docs;</span><br><span class="line">  docs.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">  docs[<span class="number">0</span>].url = <span class="string">"http://example.com"</span></span><br><span class="line">  docs[<span class="number">0</span>].score = <span class="number">-5.0</span>;</span><br><span class="line">  docs[<span class="number">1</span>].url = <span class="string">"http://example.com"</span></span><br><span class="line">  docs[<span class="number">1</span>].score = <span class="number">1</span>;</span><br><span class="line">  docs[<span class="number">2</span>].url = <span class="string">"http://example.com"</span></span><br><span class="line">  docs[<span class="number">2</span>].score = <span class="number">4</span>;</span><br><span class="line">  docs[<span class="number">3</span>].url = <span class="string">"http://example.com"</span></span><br><span class="line">  docs[<span class="number">3</span>].score = <span class="number">-99998.7</span>;</span><br><span class="line">  docs[<span class="number">4</span>].url = <span class="string">"http://example.com"</span></span><br><span class="line">  docs[<span class="number">4</span>].score = <span class="number">3.0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SortAndFileterDocs</span>(&amp;Docs);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span>(docs.<span class="built_in">size</span>() == <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">assert</span>(docs[<span class="number">0</span>].score == <span class="number">4</span>);</span><br><span class="line">  <span class="built_in">assert</span>(docs[<span class="number">1</span>].score == <span class="number">3.0</span>);</span><br><span class="line">  <span class="built_in">assert</span>(docs[<span class="number">2</span>].score == <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这段测试代码至少犯了8条错误：</p><ul><li>测试太长，充满不重要的细节</li><li>增加新测试将很不容易</li><li>测试失败的消息不是很有帮助。如果测试失败，它仅仅是“Assertion failed:docs.size() == 3”，对于调试没有什么帮助</li><li>这段测试代码想同时测完所有东西。拆分为多个测试会更具可读性</li><li>测试的输入不是很简单，尤其是“-99998.7”这种夸张的数值</li><li>它没有其他测试其他极端输入，比如空输入向量，很长的向量等</li><li>函数名字没有什么实意</li></ul><p>存在一种对测试较好的开发方式，即大名鼎鼎的测试驱动开发(TDD)。其支持者相信这种流程对没有测试的代码来将会做出极大的质量改进。无论你选择那种驱动开发方式，至少通过在写代码时候想着测试这件事能够帮助我们把代码写的更好。</p><h3 id="第15章—设计并改进“分钟-x2F-小时计数器”"><a href="#第15章—设计并改进“分钟-x2F-小时计数器”" class="headerlink" title="第15章—设计并改进“分钟/小时计数器”"></a>第15章—设计并改进“分钟/小时计数器”</h3><p>见 <a href="https://awesome-programming-books.github.io/clean-code/%E7%BC%96%E5%86%99%E5%8F%AF%E8%AF%BB%E4%BB%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF.pdf">编写可读代码的艺术</a> 第十五章</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++实用的库</title>
      <link href="/2022/12/01/c-you-yong-de-ku/"/>
      <url>/2022/12/01/c-you-yong-de-ku/</url>
      
        <content type="html"><![CDATA[<p>c++和Python不同，后者有pip这样的工具来管理模组。c++很多库需要自己下载源码编译。本文旨在分享那些实用的库的安装使用方法</p><h3 id="Boost库"><a href="#Boost库" class="headerlink" title="Boost库"></a>Boost库</h3><p>一定首先安装Boos库，他是很多其他库的基石</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mpi-default-dev　</span><br><span class="line">sudo apt-get install libicu-dev　   </span><br><span class="line">sudo apt-get install python-dev　</span><br><span class="line">sudo apt-get install libbz2-dev　</span><br></pre></td></tr></tbody></table></figure><p>boost库源文件下载 <a href="https://sourceforge.net/projects/boost/">https://sourceforge.net/projects/boost/</a><br>解压后进入文件夹执行</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./bootstrap.sh</span><br><span class="line">sudo ./b2</span><br><span class="line">sudo ./b2 install</span><br></pre></td></tr></tbody></table></figure><p><strong>这个过程可能很久..</strong><br><a href="https://www.cnblogs.com/nanmi/p/15161211.html">安装Boost库</a></p><h3 id="NumCPP"><a href="#NumCPP" class="headerlink" title="NumCPP"></a>NumCPP</h3><p>熟悉Python的人一定用过NumPy，同理c++也有这样的库。<br><a href="https://www.cnblogs.com/nanmi/p/15161211.html">安装NumCPP库</a></p><h3 id="openCV"><a href="#openCV" class="headerlink" title="openCV"></a>openCV</h3><p>去github下载源码然后build<br><a href="https://www.geeksforgeeks.org/how-to-install-opencv-in-c-on-linux/">ref</a></p>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++编译那些事儿</title>
      <link href="/2022/12/01/c-bian-yi-na-xie-shi/"/>
      <url>/2022/12/01/c-bian-yi-na-xie-shi/</url>
      
        <content type="html"><![CDATA[<p>我首先深入学习了Python，然后才是c++。尽管本科一年级学过c语言，但是在visual studio里面的一件编译运行和在Linux下手动编译很不一样。</p><h2 id="为什么要编译"><a href="#为什么要编译" class="headerlink" title="为什么要编译"></a>为什么要编译</h2><p>说白了就是把高级语言翻译成汇编语言、机器码这种计算机能够理解的语言。Python相当于边编译边运行，而c++先编译完再运行，后者自然速度起飞。</p><h2 id="编译工具"><a href="#编译工具" class="headerlink" title="编译工具"></a>编译工具</h2><p>长话短说，对于Linux下的cpp文件，我们可以使用免费开源的g++，比如<code>g++ main.cpp -o demo</code> 是把main.cpp编译并生成名为demo的可执行文件。</p><p>g++是GCC中的GUN C++ Compiler。当程序只有一个源文件时，直接就可以用gcc/g++命令编译。但是当程序包含很多个源文件时，这是一件很头疼的事情！</p><p>所以出现了make工具！make工具可以看成是一个智能的批处理工具，它本身并没有编译和链接的功能，而是用类似于批处理的方式—通过调用makefile文件中用户指定的命令来进行编译和链接的。</p><p>makefile是什么？简单的说就像一首歌的乐谱，make工具就像指挥家，指挥家根据乐谱指挥整个乐团怎么样演奏，make工具就根据makefile中的命令进行编译和链接的。makefile命令中就包含了调用g++（也可以是别的编译器）去编译某个源文件的命令。</p><h3 id="make-vs-Cmake"><a href="#make-vs-Cmake" class="headerlink" title="make vs Cmake"></a>make vs Cmake</h3><p>makefile在一些简单的工程完全可以人工手下，但是当工程非常大的时候，手写makefile也是非常麻烦的，如果换了个平台makefile又要重新修改。</p><p>这时候就出现了Cmake这个工具，cmake就可以更加简单的生成makefile文件给上面那个make用。当然cmake还有其他功能，就是可以跨平台生成对应平台能用的makefile，你不用再自己去修改了。</p><p>可是cmake根据什么生成makefile呢？它又要根据一个叫CMakeLists.txt文件去生成makefile。</p><h3 id="Cmake-vs-Bazel"><a href="#Cmake-vs-Bazel" class="headerlink" title="Cmake vs Bazel"></a>Cmake vs Bazel</h3><p>Bazel是Google开源的编译构建工具，以Monolithic Repository为理念。与makefile &amp; CMake不同，Bazel另起炉灶，采用client/server运行模式，为云编译而生。Bazel工具将编译过程分三个阶段：Load Phase/Analysis Phase/Execution phase。研发人员实现workspace/build/.bzl三种文件，Bazel执行这些文件生成action graph，执行action来构建项目。</p><h2 id="怎么选择编译工具？"><a href="#怎么选择编译工具？" class="headerlink" title="怎么选择编译工具？"></a>怎么选择编译工具？</h2><p>因为Bazel采用了类似Python的语法，所以其学习曲线相比CMake要平缓一些。Bazel对thirdparty支持还是非常友好的。</p><p>综合考虑时，CMake是一个尽管保守但仍旧不错的选择。我个人建议，如果你的团队在用Bazel，则可以尝试Bazel。否则仍然推荐先使用Cmake。</p><p><a href="https://blog.csdn.net/hblhly/article/details/80740493">ref1</a><br><a href="https://zhuanlan.zhihu.com/p/112712537">ref2</a><br><a href="https://www.jianshu.com/p/d01472734a78">ref3</a></p>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变得更强</title>
      <link href="/2022/12/01/bian-de-geng-qiang/"/>
      <url>/2022/12/01/bian-de-geng-qiang/</url>
      
        <content type="html"><![CDATA[<h3 id="漫画资本论"><a href="#漫画资本论" class="headerlink" title="漫画资本论"></a>漫画资本论</h3><p>一本轻松有趣的资本论入门漫画书，主要讲述的是资本论三卷中第一卷内容，让你对全书有一个大致了解。适合零基础的同志学习。<br><a href="https://www.bilibili.com/read/cv10516935/">漫画资本论(上)</a>  <a href="https://www.bilibili.com/read/cv10517038/">漫画资本论(下)</a></p>]]></content>
      
      
      <categories>
          
          <category> 变得更强 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书 </tag>
            
            <tag> 变得更强 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>待更新清单</title>
      <link href="/2022/12/01/dai-geng-xin/"/>
      <url>/2022/12/01/dai-geng-xin/</url>
      
        <content type="html"><![CDATA[<h3 id="c-学习查漏补缺"><a href="#c-学习查漏补缺" class="headerlink" title="c++学习查漏补缺"></a>c++学习查漏补缺</h3><h3 id="c-库函数过一遍"><a href="#c-库函数过一遍" class="headerlink" title="c++库函数过一遍"></a>c++库函数过一遍</h3><h3 id="数据结构和算法学习系列"><a href="#数据结构和算法学习系列" class="headerlink" title="数据结构和算法学习系列"></a>数据结构和算法学习系列</h3><h3 id="一些有趣的开源项目分享"><a href="#一些有趣的开源项目分享" class="headerlink" title="一些有趣的开源项目分享"></a>一些有趣的开源项目分享</h3><h3 id="pypy-x2F-CPython"><a href="#pypy-x2F-CPython" class="headerlink" title="pypy / CPython"></a>pypy / CPython</h3>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
