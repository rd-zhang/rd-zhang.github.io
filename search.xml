<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vim最常用的命令大全</title>
      <link href="/2023/01/29/vim-chang-yong-ming-ling/"/>
      <url>/2023/01/29/vim-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<p>最最最最简单，使用频率最高的vim命令，掌握之后不敢说精通也算个vim高手了！</p><h3 id="vim三大模式"><a href="#vim三大模式" class="headerlink" title="vim三大模式"></a>vim三大模式</h3><p>vim共有三个模式：功能模式、插入模式、可视模式<br>刚进入vim时即为功能模式，插入模式在左下角会显示“– insert –”， 可视模式左下角会显示“– visual –”<br>功能模式下可以进入另外两个模式，另外两个模式下按esc可以退出回到功能模式</p><h3 id="插入模式–进入-x2F-退出"><a href="#插入模式–进入-x2F-退出" class="headerlink" title="插入模式–进入/退出"></a>插入模式–进入/退出</h3><p>大多数人第一次使用vim应该都是阵亡再次吧hhh<br>从功能模式进入插入模式，有三种方法：i(nsert)，a，o。i和a其实区别不大，就是一个在当前光标前一个在后，o则是在当前行下插入一行。其实可以只使用i，然后在插入模式里换行也不麻烦很多。</p><p>想要从插入模式退出只需要按<code>esc</code></p><h3 id="可视模式–进入-x2F-退出"><a href="#可视模式–进入-x2F-退出" class="headerlink" title="可视模式–进入/退出"></a>可视模式–进入/退出</h3><p>按<code>v</code>进入可视模式，按<code>esc</code>或<code>v</code>即可退出</p><h3 id="移动光标-x2F-翻页"><a href="#移动光标-x2F-翻页" class="headerlink" title="移动光标/翻页"></a>移动光标/翻页</h3><p>在功能模式下，按ctrl+f/d为向下翻页，按ctrl+b/u为向上翻页。区别在于，forward/backward比down/up翻页更快，仅此而已hhh<br>推荐使用ctrl+d 和 ctrl+b， 无他，就是 方便左手按键2333</p><h3 id="复制-x2F-剪切-x2F-粘贴-x2F-撤销-x2F-redo-x2F-repeat"><a href="#复制-x2F-剪切-x2F-粘贴-x2F-撤销-x2F-redo-x2F-repeat" class="headerlink" title="复制/剪切/粘贴/撤销/redo/repeat"></a>复制/剪切/粘贴/撤销/redo/repeat</h3><p>在功能模式下<br><code>yy</code>复制(yank)<br><code>dd</code>剪切<br><code>p</code>粘贴<br><code>x</code>删除(处决)<br><code>u</code>撤销<br><code>.</code>重复，比<code>ctrl+r</code>常用</p><p>聪明的你应该发现了盲点：那如何复制半行呢？<br>只需进入可视模式，这时候<code>yy</code>被光标圈住的部分就行了！</p><h3 id="vim批量操作"><a href="#vim批量操作" class="headerlink" title="vim批量操作"></a>vim批量操作</h3><p>聪明的vim提供了一个骚操作，在任何命令前加上数字n，即可重复n次命令，比如<code>5yy</code>就是复制五行：）<br>基本上，数字可以跟大多数命令组合使用，自行探索即可</p><h3 id="查找字符-串"><a href="#查找字符-串" class="headerlink" title="查找字符(串)"></a>查找字符(串)</h3><p>在功能模式下<br>查找单个字符为<code>f{char}</code>或者<code>F{char}</code>，区别是一个向下找一个向上找。但是其实如果向下没有找到vim会从头再找直到回到光标处(vim是不是很聪明hh)。所以只需要记忆一个就行<br>想要查找字符串，将f换成<code>/</code>符号，F换成<code>?</code>即可</p><h3 id="替换字符"><a href="#替换字符" class="headerlink" title="替换字符"></a>替换字符</h3><p>在功能模式下<br>最常用的是全局替换：<code>:%s/&lt;target&gt;/&lt;replacement&gt;</code>，所有target都会被替换为replacement<br>替换仅当前行内、替换若干行target等高级功能请问谷歌</p><h3 id="保存-x2F-退出vim"><a href="#保存-x2F-退出vim" class="headerlink" title="保存/退出vim"></a>保存/退出vim</h3><p>这应该是大多数人第一次使用vim最困惑的地方，“ctrl+c”怎么不管用了啊233333<br>在功能模式下键入<code>:</code>，然后再组合使用命令。这里其实可以理解为全局命令，相当于word里面最上面功能栏那些命令。<br>比如<code>:write</code>或者其缩写<code>:w</code>就是保存文档，(q)uit是退出，也可以组合使用<code>:wq</code>就是保存并退出；<code>:q!</code>为不保存退出。此外还有诸如<code>saveas</code>，<code>help</code>等命令，你可以通过tab补全方式找到。<br><br></p><p>剩下的功能，比如打开多个文档时分屏、移动光标到某行特定位置、找到下一个特殊字符等高级玩法不在此讨论。因为想要一口气记住vim所有命令是不现实的，况且vim只是一个工具，使用hjkl/上下左右键移动光标也慢不了多少。熟能生巧，形成自己的习惯和肌肉记忆才是王道！</p>]]></content>
      
      
      <categories>
          
          <category> vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python高级玩法整理</title>
      <link href="/2023/01/11/python-gao-ji-wan-fa-zheng-li/"/>
      <url>/2023/01/11/python-gao-ji-wan-fa-zheng-li/</url>
      
        <content type="html"><![CDATA[<h3 id="Python-正则表达式"><a href="#Python-正则表达式" class="headerlink" title="Python 正则表达式"></a>Python 正则表达式</h3><p>正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。<br><strong>re模块</strong> 使 Python 语言拥有全部的正则表达式功能。</p><p><strong>re.match</strong> 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match() 就返回 none。</p><p><strong>re.search</strong> 扫描整个字符串并==只返回第一个==成功的匹配。</p><pre class=" language-py"><code class="language-py">import restring = "Cats are smarter than dogs"matchObj = re.match( r'(.*) are (.*?) .*', string, re.M|re.I)if matchObj:    # group和groups用法   print ("matchObj.groups() : ", matchObj.groups())   print ("matchObj.group(0) : ", matchObj.group())   print ("matchObj.group(1) : ", matchObj.group(1))   print ("matchObj.group(2) : ", matchObj.group(2))   print("")   # span用法   print ("matchObj.span(0) : ", matchObj.span(0))   print ("matchObj.span(1) : ", matchObj.span(1))   print ("matchObj.span(2) : ", matchObj.span(2))else:   print ("No match!!")</code></pre><p>Python 的 re 模块提供了 <strong>re.sub</strong> 用于替换字符串中的匹配项。<br><code>re.sub(pattern, repl, string, count=0, flags=0)</code></p><p>其中<code>repl</code>也可以是一个函数</p><p><strong>compile</strong> 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。</p><p><strong>findall</strong> 在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果有多个匹配模式，则返回元组列表，如果没有找到匹配的，则返回空列表。</p><p><strong>re.finditer</strong> 和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。</p><p><strong>re.split</strong> split 方法按照能够匹配的子串将字符串分割后返回列表</p><h3 id="Python-CGI编程"><a href="#Python-CGI编程" class="headerlink" title="Python CGI编程"></a>Python CGI编程</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h3 id="-3"><a href="#-3" class="headerlink" title=""></a></h3><h3 id="-4"><a href="#-4" class="headerlink" title=""></a></h3><h3 id="-5"><a href="#-5" class="headerlink" title=""></a></h3><h3 id="-6"><a href="#-6" class="headerlink" title=""></a></h3><p>(ref)[<a href="https://www.runoob.com/python/python-reg-expressions.html]">https://www.runoob.com/python/python-reg-expressions.html]</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell学习笔记</title>
      <link href="/2023/01/06/shell-xue-xi-bi-ji/"/>
      <url>/2023/01/06/shell-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>记录shell学习过程中一些重要的点</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>注意，赋值号=的周围不能有空格，这可能和你熟悉的大部分编程语言都不一样。<br><br></p><p>推荐给所有变量加上花括号{ }，这是个良好的编程习惯。<br><br></p><p>如果变量的内容是数字，那么可以不加引号；如果真的需要原样输出就加单引号；其他没有特别要求的字符串等最好都加上双引号，定义变量时加双引号是最常见的使用场景。<br><br></p><p>使用 <strong>readonly</strong> 命令可以将变量定义为只读变量，只读变量的值不能被改变。<br><br></p><p>使用 <strong>unset</strong> 命令可以删除变量。<br><br></p><h3 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h3><p>==variable=`commands`==  OR<br>==variable=$(commands)==<br> 两种方式都可以，但是推荐第二种，因为反引号毕竟看起来像单引号，有时候会对查看代码造成困扰，不过$() 仅在 Bash Shell 中有效，而反引号可在多种 Shell 中使用。<br><br></p><h3 id="Shell位置参数（命令行参数）"><a href="#Shell位置参数（命令行参数）" class="headerlink" title="Shell位置参数（命令行参数）"></a>Shell位置参数（命令行参数）</h3><p>运行 Shell 脚本文件时我们可以给它传递一些参数，这些参数在脚本文件内部可以使用$n的形式来接收，例如，$1 表示第一个参数，$2 表示第二个参数，依次类推。</p><br><h3 id="Shell特殊变量：Shell-、-、-、-、"><a href="#Shell特殊变量：Shell-、-、-、-、" class="headerlink" title="Shell特殊变量：Shell $#、$*、$@、$?、$$"></a>Shell特殊变量：Shell $#、$*、$@、$?、$$</h3><table><thead><tr><th>变量</th><th>含义</th></tr></thead><tbody><tr><td>$0</td><td>当前脚本的文件名。</td></tr><tr><td>$n</td><td>当前脚本的文件名。</td></tr><tr><td>$#</td><td>传递给脚本或函数的参数个数。</td></tr><tr><td>$*</td><td>传递给脚本或函数的所有参数。(作为一个整体)</td></tr><tr><td>$@</td><td>传递给脚本或函数的所有参数。(每个作为独立个体)</td></tr><tr><td>$?</td><td>上个命令的退出状态，或函数的返回值。</td></tr><tr><td>$$</td><td>当前 Shell 进程 ID。</td></tr></tbody></table><br><h3 id="Shell字符串"><a href="#Shell字符串" class="headerlink" title="Shell字符串"></a>Shell字符串</h3><pre class=" language-shell"><code class="language-shell">str1=c.biancheng.netstr2="shell script"str3='C语言中文网'</code></pre><ol><li><p>由单引号’ ‘包围的字符串：<br>任何字符都会原样输出，在其中使用变量是无效的。<br>字符串中不能出现单引号，即使对单引号进行转义也不行。</p></li><li><p>由双引号” “包围的字符串：<br>如果其中包含了某个变量，那么该变量会被解析（得到该变量的值），而不是原样输出。<br>字符串中可以出现双引号，只要它被转义了就行。</p></li><li><p>不被引号包围的字符串<br>不被引号包围的字符串中出现变量时也会被解析，这一点和双引号” “包围的字符串一样。<br>字符串中不能出现空格，否则空格后边的字符串会作为其他变量或者命令解析。</p></li></ol><p>在 Shell 中获取字符串长度很简单，具体方法如下：</p><p>```shell<br>$</p>]]></content>
      
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建你的第一个云数据库</title>
      <link href="/2023/01/06/da-jian-di-yi-ge-yun-shu-ju-ku/"/>
      <url>/2023/01/06/da-jian-di-yi-ge-yun-shu-ju-ku/</url>
      
        <content type="html"><![CDATA[<p>最近开始接触数据库，第一个应用的自然是大名鼎鼎的MySQL。本地安装MySQL并不复杂，但是如何用数据库实现一些有趣的事值得深究。</p><p>经过探索，我发现了两个宝藏云数据库网站 <strong>完全免费！</strong> ，每个月提供的空间、读写次数完全能够满足个人学习与小型应用。</p><ol><li><a href="https://memfiredb.com/?utm_source=zhhwj">memfiredb</a>，有中文支持，但是空间稍小，而且只能创建两个仓库…</li><li><a href="https://app.planetscale.com/">planetscale</a>，虽然是美国网站，但是直接访问没有任何问题，新建仓库时选择默认节点(比如我默认是在弗吉尼亚)即可。</li></ol><p>同时在本地安装mysql cli，需要GUI的话推荐使用Navicat或者EMMA这些主流GUI，或者直接在命令行敲键盘2333<br>具体的创建更改删除表等指令可以参考菜鸟教程或者廖雪峰的网站(廖雪峰的SQL教程烂尾且只适合小白快速入门，作为字典还是太浅薄了)</p><p>TODO 写一个微信小程序，可以实现在线读取显示云数据库内容，比如我曾到访过的国家城市等。</p>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分享 </tag>
            
            <tag> MySQL </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023年目标</title>
      <link href="/2023/01/01/2023-mu-biao/"/>
      <url>/2023/01/01/2023-mu-biao/</url>
      
        <content type="html"><![CDATA[<p>不知不觉已经2023年了，我也刚刚完成在校生到工程师的转变。</p><p>2023年给自己立下几个flag，希望能够变得更强：</p><h4 id="1-拓展技术广度"><a href="#1-拓展技术广度" class="headerlink" title="1. 拓展技术广度"></a>1. 拓展技术广度</h4><p>了解常见技术基本原理和用法，做一些hello world，包括且不限于：</p><ul><li>Shell</li><li>SQL</li><li>Python Tkinter</li><li>JavaScript</li><li>PyQT</li><li>微信小程序<br>……</li></ul><h4 id="2-巩固Python开发能力"><a href="#2-巩固Python开发能力" class="headerlink" title="2. 巩固Python开发能力"></a>2. 巩固Python开发能力</h4><p>做一些小项目，比如写桌游脚本，实用的爬虫程序，自动化办公程序等</p><h4 id="3-完成c-的进阶"><a href="#3-完成c-的进阶" class="headerlink" title="3. 完成c++的进阶"></a>3. 完成c++的进阶</h4><p>逆水行舟不进则退，c++入门后要趁热打铁，除了看完 c++ primer，还要多练手，多看一些项目源代码，可以把写过的python项目用c++写一遍</p><h4 id="4-算法和数据结构进阶"><a href="#4-算法和数据结构进阶" class="headerlink" title="4. 算法和数据结构进阶"></a>4. 算法和数据结构进阶</h4><p>反复看算法导论以及一些网站教程，多刷题，争取达到leetcode 500 题(中等以上题150道)</p>]]></content>
      
      
      <categories>
          
          <category> 变得更强 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 变得更强 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建docker镜像并运行脚本</title>
      <link href="/2022/12/30/chuang-jian-docker-jing-xiang-bing-yun-xing-jiao-ben/"/>
      <url>/2022/12/30/chuang-jian-docker-jing-xiang-bing-yun-xing-jiao-ben/</url>
      
        <content type="html"><![CDATA[<h3 id="本文将尝试运用Docker创建镜像的方式运行一个python脚本，并将镜像上传到docker-hub"><a href="#本文将尝试运用Docker创建镜像的方式运行一个python脚本，并将镜像上传到docker-hub" class="headerlink" title="本文将尝试运用Docker创建镜像的方式运行一个python脚本，并将镜像上传到docker hub"></a>本文将尝试运用Docker创建镜像的方式运行一个python脚本，并将镜像上传到docker hub</h3><h4 id="1-创建文件夹"><a href="#1-创建文件夹" class="headerlink" title="1. 创建文件夹"></a>1. 创建文件夹</h4><p>比如在/home下创建docker_1文件夹，然后在该文件夹内创建/docker_assignment文件</p><h4 id="2-创建运行的py脚本和dockerfile"><a href="#2-创建运行的py脚本和dockerfile" class="headerlink" title="2. 创建运行的py脚本和dockerfile"></a>2. 创建运行的py脚本和dockerfile</h4><p><code>test.py</code>内容：</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># -*-coding:utf-8-*-</span><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hi, this is a test created by Tutu. Hope you enjoy playing with Docker :)"</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h4 id="3-配置dockerfile"><a href="#3-配置dockerfile" class="headerlink" title="3. 配置dockerfile"></a>3. 配置dockerfile</h4><pre class=" language-dockerfile"><code class="language-dockerfile">#Deriving the latest base imageFROM python:3.8.16-buster#Labels as key value pairLABEL Maintainer="Tutu.Zhang"# Any working directory can be chosen as per choice like '/' or '/home' etc# i have chosen /usr/app/srcWORKDIR /home#to COPY the remote file at working directory in containerCOPY test.py ./#CMD instruction should be used to run the software#contained by your image, along with any arguments.CMD [ "python", "./test.py"]</code></pre><p>通过在VS Code安装docker插件，我们可以很方便的访问docker hub。这里我没有无脑选择latest的python tag，而是选择了跟我本地一样的环境，即python:3.8.16-buster。</p><p>其他的配置都比较简单，注释也有解释，不再赘述。</p><h4 id="4-制作docker镜像"><a href="#4-制作docker镜像" class="headerlink" title="4. 制作docker镜像"></a>4. 制作docker镜像</h4><pre><code>docker image build -t rdzhang96/test:test_0.1 /home/zrd/docker_1/docker_assignment/</code></pre><p>其中命名部分<code>rdzhang96/test:test_0.1</code>要小心，因为如果之后想push到仓库的话这里冒号前面部分必须跟仓库名对应。不过，后面重命名也是可以的。</p><h4 id="5-验证并运行你的新镜像"><a href="#5-验证并运行你的新镜像" class="headerlink" title="5. 验证并运行你的新镜像"></a>5. 验证并运行你的新镜像</h4><p>使用<code>docker images</code>命令可以查看到已经创建成功新镜像，然后使用<code>docker run</code>命令即可运行。</p><h4 id="6-上传到docker-hub仓库"><a href="#6-上传到docker-hub仓库" class="headerlink" title="6. 上传到docker hub仓库"></a>6. 上传到docker hub仓库</h4><p>使用<code>docker push rdzhang96/test:test_0.1 </code>命令即可上传到仓库，这样别人或者别的设备也可以获取你制作的镜像并愉快的运行了！</p><p><a href="https://www.geeksforgeeks.org/how-to-run-a-python-script-using-docker/">ref</a></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++全部13种数据结构</title>
      <link href="/2022/12/27/c-quan-bu-13-chong-shu-ju-jie-gou/"/>
      <url>/2022/12/27/c-quan-bu-13-chong-shu-ju-jie-gou/</url>
      
        <content type="html"><![CDATA[<h3 id="1-数组-Array"><a href="#1-数组-Array" class="headerlink" title="1.数组 Array"></a>1.数组 Array</h3><p>数组在初始化的时候就需要知道其大小，后续是不可以改变其大小的，可以通过下标来获取某个 index 中存放的元素。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;array></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">void</span> <span class="token function">testArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 创建一个数组</span>    std<span class="token operator">::</span>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token operator">></span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 对数组进行遍历</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> i <span class="token operator">:</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 取第一个值，通过 [index] 获取</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a[0] = "</span> <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 修改数组中第一个值</span>    a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     at 会检查 index 是否越界，越界将 crash，而 a[index] 不会;     libc++abi.dylib: terminating with uncaught exception of type std::out_of_range: array::at     */</span>    a<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 数组是否为空</span>    a<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 求数组的长度</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a.size()="</span> <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取第4个值</span>    <span class="token keyword">int</span> value <span class="token operator">=</span> std<span class="token operator">::</span>get<span class="token operator">&lt;</span><span class="token number">4</span><span class="token operator">></span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a(4) = "</span> <span class="token operator">&lt;&lt;</span> value <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建一个空数组，数组中的值为0或者是与类型相等的其它值</span>    std<span class="token operator">::</span>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token operator">></span> a2<span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"end a2"</span> <span class="token operator">&lt;&lt;</span> a2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 比较两个数组中的元素是否都相等</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> a2<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="2-可变数组-向量vector"><a href="#2-可变数组-向量vector" class="headerlink" title=" 2.可变数组,向量vector "></a><font color="red"> 2.可变数组,向量vector </font></h3><p>在C++中使用 Vector 存当可变数组，它的容量可以动态改变，初始化的时候不需要确定数组的大小。使用的方法和数组基本一致。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">void</span> <span class="token function">testVector</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     vector&lt;T> 它与Array不同，它的大小是可变的     */</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> v<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 增加容器的容量，至少容纳 20 个元素</span>    v<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化一个向量</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 以数组初始化一个vector</span>    std<span class="token operator">::</span>array<span class="token operator">&lt;</span>std <span class="token operator">::</span> string<span class="token punctuation">,</span> <span class="token number">5</span><span class="token operator">></span> words <span class="token punctuation">{</span><span class="token string">"one"</span><span class="token punctuation">,</span> <span class="token string">"two"</span><span class="token punctuation">,</span><span class="token string">"three"</span><span class="token punctuation">,</span> <span class="token string">"four"</span><span class="token punctuation">,</span> <span class="token string">"five"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> words_copy <span class="token punctuation">{</span>std<span class="token operator">::</span><span class="token function">begin</span><span class="token punctuation">(</span>words<span class="token punctuation">)</span> <span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">end</span><span class="token punctuation">(</span>words<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 通过 v[index] 获取或者修改元素</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"v[0] = "</span> <span class="token operator">&lt;&lt;</span> v2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取第一个元素</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"v.front() = "</span> <span class="token operator">&lt;&lt;</span> v2<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 在末尾插入值为 9</span>    v2<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 在末尾插入值为 2</span>    v2<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 删除第一个元素，传入的值是一个迭代器</span>    v2<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>v2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 长度</span>    v2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 删除所有元素</span>    v2<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 删除末尾元素</span>    v2<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 在末尾插入元素</span>    v2<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>v2<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="3-双向链表-list"><a href="#3-双向链表-list" class="headerlink" title="3.双向链表 list"></a>3.双向链表 list</h3><p>双向链表具有指向前一个节点和后一个节点的指针。C++ 中本身提供了双向链表的实现。<br><img src="https://mmbiz.qpic.cn/mmbiz_png/rzprzksWzShI4sWCGGv4pDSuVBy2oqeAAbV7ZRvicNWEVfIFqGib0PTdibULy7kTAC7bskPorXapGTibKEzLKHibceA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="image"></p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;list></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    list<span class="token operator">&lt;</span>string<span class="token operator">></span> words <span class="token punctuation">{</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"list"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 头部插入元素</span>    words<span class="token punctuation">.</span><span class="token function">push_front</span><span class="token punctuation">(</span><span class="token string">"push_fron"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    words<span class="token punctuation">.</span><span class="token function">emplace_front</span><span class="token punctuation">(</span><span class="token string">"emplace_front"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 尾部插入</span>    words<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token string">"push_back"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    words<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token string">"emplace_back"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 指定位置插入</span>    words<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">,</span> <span class="token string">"insert"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 删除元素</span>    words<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"push_fron"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 通过迭代器来访问链表中的元素</span>    list<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">::</span>iterator beg_iter <span class="token operator">=</span> words<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    list<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">::</span>iterator end_iter <span class="token operator">=</span> words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"beg_iter:"</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>beg_iter <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"end_iter:"</span>  <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>end_iter <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> endl  <span class="token operator">&lt;&lt;</span> <span class="token string">"now a is:"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> a <span class="token operator">:</span> words<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="4-单链表-forward-list"><a href="#4-单链表-forward-list" class="headerlink" title="4.单链表 forward_list"></a>4.单链表 forward_list</h3><p>单链表只有指向下一个节点的指针。<br><img src="https://mmbiz.qpic.cn/mmbiz_png/rzprzksWzSgQ1FsJQfiag6qLsggXsJCCMLbkfUNeEiaWliaicay4ST35rdMD7kMZt3sueO0bTy4czic1LbI8tJIgtfg/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="image"></p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;forward_list></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    forward_list<span class="token operator">&lt;</span>string<span class="token operator">></span> flist <span class="token punctuation">{</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"lefe"</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 计算它的大小</span>    <span class="token keyword">auto</span> count <span class="token operator">=</span> <span class="token function">distance</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>flist<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>flist<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"size:"</span> <span class="token operator">&lt;&lt;</span> count <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 头部插入</span>    flist<span class="token punctuation">.</span><span class="token function">push_front</span><span class="token punctuation">(</span><span class="token string">"before3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 在头部插入</span>    flist<span class="token punctuation">.</span><span class="token function">insert_after</span><span class="token punctuation">(</span>flist<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"before2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 在头结点前面插入</span>    flist<span class="token punctuation">.</span><span class="token function">insert_after</span><span class="token punctuation">(</span>flist<span class="token punctuation">.</span><span class="token function">before_begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"before1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 遍历单链表</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> word <span class="token operator">:</span> flist<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> word <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="5-队列-queue"><a href="#5-队列-queue" class="headerlink" title="5.队列 queue"></a>5.队列 queue</h3><p>队列是一种先进先出的数据结构，C++底层使用「双端队列」实现。<br><img src="https://mmbiz.qpic.cn/mmbiz_png/rzprzksWzSgeibVU3xHFrRxaYF9UbTgaYKH4dVVnM176VkxEqUl8cfw4QWmkYnjCuj1pMJL3YSFiaxbcrH5S8WWg/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="image"></p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;queue></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> s<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 入队</span>    s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"s.front is: "</span> <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"s.back is: "</span> <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"s.size is: "</span> <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"pop the tail of s"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 出队</span>    s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"s.size now is: "</span> <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="6-双端队列deque"><a href="#6-双端队列deque" class="headerlink" title="6.双端队列deque"></a>6.双端队列deque</h3><p>双端队列可以对队头和队尾元素进行操作。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;queue></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 初始化一个空双端队列</span>    deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> my_deque<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化一个含有两个元素双端队列</span>    deque<span class="token operator">&lt;</span>string<span class="token operator">></span> name_queue <span class="token punctuation">{</span><span class="token string">"lefe"</span><span class="token punctuation">,</span> <span class="token string">"wsy"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"[0] = "</span> <span class="token operator">&lt;&lt;</span>  name_queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取队头元素</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"front = "</span> <span class="token operator">&lt;&lt;</span>  name_queue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取队尾元素</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"back = "</span> <span class="token operator">&lt;&lt;</span>  name_queue<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 从尾部入队</span>    name_queue<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token string">"bx"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    name_queue<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="7-优先队列-priority-queue"><a href="#7-优先队列-priority-queue" class="headerlink" title="7.优先队列 priority_queue"></a>7.优先队列 priority_queue</h3><p>优先队列和普通队列一样只能在队尾插入元素，队头删除元素，但是它有一个特点，队头永远是优先级最大的元素，出队顺序与入队顺序无关。即，对于这样一个队列<code>priority_queue = {1,4,6,2}</code>，使用<code>priority_queue.pop()</code>将会挤出 ==6== 而不是 ==1==。</p><h3 id="8-堆heap"><a href="#8-堆heap" class="headerlink" title="8.堆heap"></a>8.堆heap</h3><p>堆是一颗完全二叉树，某个节点的值总是不大于父节点的值（大根堆），可以使用数组来表示一个堆，C++ 默认提供的是大根堆。<br>C++ 中的堆是通过算法实现的，需要导入<code>#include &lt;algorithm&gt;</code></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/rzprzksWzShRCW2pxlz5wK5YXNj2xFTQMGDlUWCgqibs8BXzib54DWtQALQxicX6aGfGUygl9z4hYoW0CW1aNQsyg/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="image"></p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// Online C++ compiler to run C++ program online</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> numbers <span class="token punctuation">{</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**提供判断方法*/</span>    <span class="token comment" spellcheck="true">// make_heap(numbers.begin(), numbers.end(), [](int a,int b){return a &lt; b;});</span>    <span class="token comment" spellcheck="true">// 创建堆后，numbers 中元素的值为: 20，6，7，3，5，大根堆</span>    <span class="token function">make_heap</span><span class="token punctuation">(</span>numbers<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> numbers<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> a <span class="token operator">&lt;</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 向堆中添加元素</span>    numbers<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 重组堆：40，6，20，3，5，7 大根堆，调用 push_heap 先确保先前的 vertor 是个堆</span>    <span class="token function">push_heap</span><span class="token punctuation">(</span>numbers<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> numbers<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 移除堆顶元素，需要把 numbers 中的尾部元素移除，不会自动移除</span>    <span class="token function">pop_heap</span><span class="token punctuation">(</span>numbers<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> numbers<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    numbers<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="9-栈-stack"><a href="#9-栈-stack" class="headerlink" title="9.栈 stack"></a>9.栈 stack</h3><p>栈是一种先进后出的数据结构，C++ 底层使用双端队列实现。在以前最小栈算法中我们详细介绍了这种数据结构。图解最小栈。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/rzprzksWzSjfINrAosNyCpAvoda5DCVWticW7eXLpPQG5aYYHMP2eTlxdg35CiaXH5QN3g9ffqdTV3HQ05FKiaG4A/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="image"></p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stack></span></span><span class="token keyword">void</span> <span class="token function">testStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> s<span class="token punctuation">;</span>    s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"top="</span> <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="10-映射-map、unordered-map"><a href="#10-映射-map、unordered-map" class="headerlink" title="  10.映射 map、unordered_map "></a><font color="red">  10.映射 map、unordered_map </font></h3><p>map 是一种保存 key 和 vaule 的数据结构，key 是唯一的，相当于Python中的字典。C++ 中提供了有序的 map 和无序的 map 「unordered_map」。</p><p><strong>重复key</strong> 如果出现重复的key，如果第二次插入使用的是insert方法则不会覆盖(可以参考其源代码，会首先查询map内是否有该key)；但是如果使用[]，也即赋值的方法则可以覆盖！</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unordered_map></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;map></span></span><span class="token keyword">void</span> <span class="token function">testMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 初始化</span>    map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> string<span class="token operator">></span> m<span class="token punctuation">;</span>    pair<span class="token operator">&lt;</span>map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> string<span class="token operator">></span><span class="token operator">::</span>iterator<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">></span> ret_iter <span class="token operator">=</span>     m<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>pair<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> string<span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"lefe"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret_iter<span class="token punctuation">.</span>second <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"name have existed"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 初始化</span>    map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span> m2 <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token punctuation">{</span><span class="token number">2014</span><span class="token punctuation">,</span> <span class="token string">"iOS"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span><span class="token number">2015</span><span class="token punctuation">,</span> <span class="token string">"Android"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 单值插入</span>    m<span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"wsy"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 多值插入</span>    m<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">"age"</span><span class="token punctuation">,</span> <span class="token string">"20"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"from"</span><span class="token punctuation">,</span> <span class="token string">"nmg"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"size = "</span> <span class="token operator">&lt;&lt;</span> m<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 使用迭代器删除</span>    m<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 查找</span>    map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> string<span class="token operator">></span><span class="token operator">::</span>iterator find_iter <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"from"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>find_iter <span class="token operator">!=</span> m<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"find"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 遍历, key 是有序的</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>pair<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> string<span class="token operator">></span> v <span class="token operator">:</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">.</span>first <span class="token operator">&lt;&lt;</span> <span class="token string">" = "</span> <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">.</span>second <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 删除全部元素</span>    m<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="11-pair"><a href="#11-pair" class="headerlink" title="11.pair"></a>11.pair</h3><p>pair中保存了两个值，这两个值的类型可以是任意类型，也可以不同。通过 first 和 second 来获取对应的值。pari经常用于map的插入以及初始化。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">testPair</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    pair<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> string<span class="token operator">></span> p <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"lefex"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 通过first 和 second 来获取第一个和第二个值</span>    cout <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">.</span>first<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">.</span>second<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="12-元组-tuple"><a href="#12-元组-tuple" class="headerlink" title="12.元组 tuple"></a>12.元组 tuple</h3><p>它是 pair 的扩充版，可以存储多个不同类型的元素。<br>因此，==tuple也可以用于想要返回多个值的情况==：比如可以返回一个tuple对象，而该对象可以包含任意多个任意类型的内容。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">testTuple</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    pair<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> string<span class="token operator">></span> p <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"lefe"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建一个 tuple，类型为 &lt;strinng, int, double, pair></span>    <span class="token keyword">auto</span> my_tuple <span class="token operator">=</span> <span class="token function">make_tuple</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">10.3</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取第一个元素</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"0 = "</span> <span class="token operator">&lt;&lt;</span> get<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">></span><span class="token punctuation">(</span>my_tuple<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取第二个元素</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"1 = "</span> <span class="token operator">&lt;&lt;</span> get<span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">></span><span class="token punctuation">(</span>my_tuple<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="13-集合-set"><a href="#13-集合-set" class="headerlink" title="13.集合 set"></a>13.集合 set</h3><p>集合中不能存储相同的元素，它底层基于平衡二叉树实现，在前面的文章中我们通过二分搜索树实现了 set。<a href="https://mp.weixin.qq.com/s?__biz=MzUzMTk3ODc0OA==&amp;mid=2247484185&amp;idx=1&amp;sn=0d1d43b565c73e7f1db0311edbe0834b&amp;chksm=fabb038acdcc8a9cfd41954d3ab880d4a93e9756527a5ff331cf340e49c1ee4466626531da78&amp;scene=21#wechat_redirect">使用 BST 实现 Set</a>。在 C++ 中 set 是有序的，同时也提供了无序的 set 「UnorderSet」。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;set></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unordered_set></span></span><span class="token keyword">void</span> <span class="token function">testSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> s <span class="token punctuation">{</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    s<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 3,4,5,7</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> v <span class="token operator">:</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> v <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        unordered_set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> us <span class="token punctuation">{</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    us<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 7,3,4,5</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> v <span class="token operator">:</span> us<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> v <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>不同的数据结构包含了很多类方法，因此还请勤加练习，才能熟练掌握各种操作！</p><p><a href="https://mp.weixin.qq.com/s/JxQjKWBe-Dg9aCyq-USPwA">ref</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法之【二分查找】</title>
      <link href="/2022/12/27/suan-fa-er-fen-cha-zhao/"/>
      <url>/2022/12/27/suan-fa-er-fen-cha-zhao/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> Python </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法复杂度</title>
      <link href="/2022/12/27/suan-fa-fu-za-du/"/>
      <url>/2022/12/27/suan-fa-fu-za-du/</url>
      
        <content type="html"><![CDATA[<p>算法所追求的就是 所需运行时间更少（时间复杂度更低）、占用内存空间更小（空间复杂度更低）</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度（Time Complexity）：在问题的输入规模为 n 的条件下，算法运行所需要花费的时间，可以记作为 T(n)。</p><p>时间复杂度的函数可以表示为：$T(n)=O(f(n))$ 。它表示的是随着问题规模 n 的增大，算法执行时间的增长趋势跟$f(n)$相同。$O$是一种渐进符号，$T(n)$称作算法的 __渐进时间复杂度__（Asymptotic time complexity），简称为 __时间复杂度__。我们关注的通常是算法用时的上界，而不用关心其用时的下界。</p><br><p>求解时间复杂度一般分为以下几个步骤:</p><ul><li>找出算法中的基本操作（基本语句）：算法中执行次数最多的语句就是基本语句，通常是最内层循环的循环体部分。</li><li>计算基本语句执行次数的数量级：只需要计算基本语句执行次数的数量级，即保证函数中的最高次幂正确即可。像最高次幂的系数和低次幂可以忽略。</li><li>用大 O 表示法表示时间复杂度：将上一步中计算的数量级放入 O 渐进上界符号中。</li></ul><h5 id="1-常数-O-1"><a href="#1-常数-O-1" class="headerlink" title="1. 常数$O(1)$"></a>1. 常数$O(1)$</h5><p>一般情况下，只要算法中不存在循环语句、递归语句，其时间复杂度都为$O(1)$。</p><p>$O(1)$只是常数阶时间复杂度的一种表示方式，并不是指只执行了一行代码。只要代码的执行时间不随着问题规模 n 的增大而增长，这样的算法时间复杂度都记为$O(1)$。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">algorithm</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    a <span class="token operator">=</span> <span class="token number">1</span>    b <span class="token operator">=</span> <span class="token number">2</span>    res <span class="token operator">=</span> a <span class="token operator">*</span> b <span class="token operator">+</span> n    <span class="token keyword">return</span> res</code></pre><h5 id="2-线性-O-n"><a href="#2-线性-O-n" class="headerlink" title="2. 线性$O(n)$"></a>2. 线性$O(n)$</h5><p>一般含有非嵌套循环，且单层循环下的语句执行次数为 n 的算法涉及线性时间复杂度。这类算法随着问题规模 n 的增大，对应计算次数呈线性增长。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">algorithm</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    sum <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>        sum <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">return</span> sum</code></pre><h5 id="3-平方-O-n-2"><a href="#3-平方-O-n-2" class="headerlink" title="3. 平方$O(n^2)$"></a>3. 平方$O(n^2)$</h5><p>一般含有双层嵌套，且每层循环下的语句执行次数为 n 的算法涉及平方时间复杂度。这类算法随着问题规模 n 的增大，对应计算次数呈平方关系增长。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">algorithm</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    res <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">return</span> res</code></pre><h5 id="4-阶乘-O-n"><a href="#4-阶乘-O-n" class="headerlink" title="4. 阶乘$O(n!)$"></a>4. 阶乘$O(n!)$</h5><p>阶乘时间复杂度一般出现在与「全排列」、「旅行商问题暴力解法」相关的算法中。这类算法随着问题规模 n 的增大，对应计算次数呈阶乘关系增长。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">permutations</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> start <span class="token operator">==</span> end<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>        <span class="token keyword">return</span>     <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">:</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        permutations<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span></code></pre><h5 id="5-对数-O-log-n"><a href="#5-对数-O-log-n" class="headerlink" title="5. 对数$O(log n)$"></a>5. 对数$O(log n)$</h5><p>对数时间复杂度一般出现在「二分查找」、「分治」这种一分为二的算法中。这类算法随着问题规模 n 的增大，对应的计算次数呈对数关系增长。</p><pre class=" language-pyton"><code class="language-pyton">def algorithm(n):    cnt = 1    while cnt < n:        cnt *= 2    return cnt</code></pre><h5 id="6-线性对数-O-nlog-n"><a href="#6-线性对数-O-nlog-n" class="headerlink" title="6. 线性对数$O(nlog n)$"></a>6. 线性对数$O(nlog n)$</h5><p>线性对数一般出现在排序算法中，例如「快速排序」、「归并排序」、「堆排序」等。这类算法随着问题规模 n 的增大，对应的计算次数呈线性对数关系增长。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">algorithm</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    cnt <span class="token operator">=</span> <span class="token number">1</span>    res <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">while</span> cnt <span class="token operator">&lt;</span> n<span class="token punctuation">:</span>        cnt <span class="token operator">*=</span> <span class="token number">2</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">return</span> res</code></pre><br><p>根据从小到大排序：<br>$ O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n) $</p><p>时间复杂度是一个关于输入问题规模 n 的函数。但是因为输入问题的内容不同，习惯将「时间复杂度」分为「最佳」、「最坏」、「平均」三种情况。一般采用平均时间复杂度作为时间复杂度的计算方式。</p><br><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>空间复杂度（Space Complexity）：在问题的输入规模为 n 的条件下，算法所占用的空间大小，可以记作为 $S(n)$。一般将 算法的辅助空间 作为衡量空间复杂度的标准。<br>除了执行时间的长短，算法所需储存空间的多少也是衡量性能的一个重要方面。而在「时间复杂度」中提到的渐进符号，也同样使用于空间复杂度的度量。</p><h5 id="1-常数-O-1-1"><a href="#1-常数-O-1-1" class="headerlink" title="1. 常数$O(1)$"></a>1. 常数$O(1)$</h5><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">algorithm</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    a <span class="token operator">=</span> <span class="token number">1</span>    b <span class="token operator">=</span> <span class="token number">2</span>    res <span class="token operator">=</span> a <span class="token operator">*</span> b <span class="token operator">+</span> n    <span class="token keyword">return</span> res</code></pre><h5 id="2-线性-O-n-1"><a href="#2-线性-O-n-1" class="headerlink" title="2. 线性$O(n)$"></a>2. 线性$O(n)$</h5><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">algorithm</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> n <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">1</span>    <span class="token keyword">return</span> n <span class="token operator">*</span> algorithm<span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span></code></pre><p>上述代码采用了递归调用的方式。每次递归调用都占用了 1 个栈帧空间，总共调用了 n 次，所以该算法的空间复杂度为$O(n)$。</p><br><p>根据从小到大排序：<br>$ O(1)&lt;O(logn)&lt;O(n)&lt;O(n^2) $</p><br><p><a href="https://algo.itcharge.cn/00.Introduction/02.Algorithm-Complexity/">ref</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《算法图解》阅读笔记</title>
      <link href="/2022/12/16/suan-fa-tu-jie-yue-du-bi-ji/"/>
      <url>/2022/12/16/suan-fa-tu-jie-yue-du-bi-ji/</url>
      
        <content type="html"><![CDATA[<h3 id="第1章-算法简介"><a href="#第1章-算法简介" class="headerlink" title="第1章 算法简介"></a>第1章 算法简介</h3><p>算法其实就是一组完成任务的指令。</p><p>一个入门级别的算法就是 <strong>二分查找</strong>, 其时间复杂度为 O(log n),即对数时间。</p><p>但是其实算法的速度指的并非时间，而是操作数的增速。</p><h3 id="第2章-排序选择"><a href="#第2章-排序选择" class="headerlink" title="第2章 排序选择"></a>第2章 排序选择</h3><p>数组和链表在内存中储存方式不同。<br>选择排序复杂度为O($n^2$)</p><h3 id="第3章-递归"><a href="#第3章-递归" class="headerlink" title="第3章 递归"></a>第3章 递归</h3><p>注意添加基线条件</p><p>经典例子–求阶乘：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">fact</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> x <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">1</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> x <span class="token operator">*</span> fact<span class="token punctuation">(</span>x<span class="token number">-1</span><span class="token punctuation">)</span></code></pre><p>总之，递归就是调用自己的函数<br>每个递归函数都包括：基线条件和递归条件</p><h3 id="第4章-快速排序"><a href="#第4章-快速排序" class="headerlink" title="第4章 快速排序"></a>第4章 快速排序</h3><p>快速排序是一种非常elegant的算法，它将用到分而治之，A.K.A. Divide &amp; Conquer 算法。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">quicksort</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> len<span class="token punctuation">(</span>array<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> array    <span class="token keyword">else</span><span class="token punctuation">:</span>        pivot <span class="token operator">=</span> array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>                less <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> array<span class="token punctuation">[</span>i<span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token keyword">if</span> i<span class="token operator">&lt;=</span>pivot<span class="token punctuation">]</span>        greater <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> array<span class="token punctuation">[</span>i<span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token keyword">if</span> i<span class="token operator">></span>pivot<span class="token punctuation">]</span>        <span class="token keyword">return</span> quicksort<span class="token punctuation">(</span>less<span class="token punctuation">)</span><span class="token operator">+</span><span class="token punctuation">[</span>pivot<span class="token punctuation">]</span><span class="token operator">+</span>quicksort<span class="token punctuation">[</span>greater<span class="token punctuation">]</span></code></pre><h3 id="第5章-散列表"><a href="#第5章-散列表" class="headerlink" title="第5章 散列表"></a>第5章 散列表</h3><p>其实就是字典……</p><h3 id="第6章-广度优先搜索"><a href="#第6章-广度优先搜索" class="headerlink" title="第6章 广度优先搜索"></a>第6章 广度优先搜索</h3><p>BFS可以帮助你找出两样东西之间的最短距离，比如跳棋AI计算最少走多少步可以获胜。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> dequegraph <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>graph<span class="token punctuation">[</span><span class="token string">"you"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"alice"</span><span class="token punctuation">,</span> <span class="token string">"bob"</span><span class="token punctuation">,</span> <span class="token string">"claire"</span><span class="token punctuation">]</span>graph<span class="token punctuation">[</span><span class="token string">"bob"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"anuj"</span><span class="token punctuation">,</span> <span class="token string">"peggy"</span><span class="token punctuation">]</span>graph<span class="token punctuation">[</span><span class="token string">"alice"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"peggy"</span><span class="token punctuation">]</span>graph<span class="token punctuation">[</span><span class="token string">"claire"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"thom"</span><span class="token punctuation">,</span> <span class="token string">"jonny"</span><span class="token punctuation">]</span>graph<span class="token punctuation">[</span><span class="token string">"anuj"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>graph<span class="token punctuation">[</span><span class="token string">"peggy"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>graph<span class="token punctuation">[</span><span class="token string">"thom"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>graph<span class="token punctuation">[</span><span class="token string">"jonny"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">search</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">:</span>    search_queue <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>    search_queue <span class="token operator">+=</span> graph<span class="token punctuation">[</span>name<span class="token punctuation">]</span>    searched <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">while</span> search_queue <span class="token punctuation">:</span>        person <span class="token operator">=</span> search_queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> person <span class="token operator">not</span> <span class="token keyword">in</span> searched <span class="token punctuation">:</span>            <span class="token keyword">if</span> person_is_seller<span class="token punctuation">(</span>person<span class="token punctuation">)</span> <span class="token punctuation">:</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Person "</span> <span class="token operator">+</span> person <span class="token operator">+</span><span class="token string">"is a mango seller"</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">else</span> <span class="token punctuation">:</span>                search_queue <span class="token operator">+=</span> graph<span class="token punctuation">[</span>person<span class="token punctuation">]</span>                searched<span class="token punctuation">.</span>append<span class="token punctuation">(</span>person<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token boolean">False</span><span class="token keyword">def</span> <span class="token function">person_is_seller</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">:</span>    <span class="token keyword">return</span> name<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'m'</span><span class="token keyword">print</span><span class="token punctuation">(</span>search<span class="token punctuation">(</span><span class="token string">'you'</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h3 id="第7章-Dijkstra算法"><a href="#第7章-Dijkstra算法" class="headerlink" title="第7章 Dijkstra算法"></a>第7章 Dijkstra算法</h3><p>BFS用于在非加权图查找<br>加权图查找使用Dijkstra (权重为正)</p><h3 id="第8章-贪婪算法"><a href="#第8章-贪婪算法" class="headerlink" title="第8章 贪婪算法"></a>第8章 贪婪算法</h3><p>贪婪算法：每步都选择最优的做法</p><h3 id="第9章-动态规划"><a href="#第9章-动态规划" class="headerlink" title="第9章 动态规划"></a>第9章 动态规划</h3><p>动态解决子问题，再解决母问题</p><h3 id="第10章-K最近邻算法"><a href="#第10章-K最近邻算法" class="headerlink" title="第10章 K最近邻算法"></a>第10章 K最近邻算法</h3><p>KNN 算法用于分类问题</p><h3 id="第11章-接下来如何做"><a href="#第11章-接下来如何做" class="headerlink" title="第11章 接下来如何做"></a>第11章 接下来如何做</h3><p>略</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++八大基础数据结构</title>
      <link href="/2022/12/15/c-ba-da-ji-chu-shu-ju-jie-gou/"/>
      <url>/2022/12/15/c-ba-da-ji-chu-shu-ju-jie-gou/</url>
      
        <content type="html"><![CDATA[<h3 id="1-数组"><a href="#1-数组" class="headerlink" title="1.数组"></a>1.数组</h3><p>数组是可以再内存中连续存储多个元素的结构，在内存中的分配也是连续的，数组中的元素通过数组下标进行访问，数组下标从0开始。例如下面这段代码就是将数组的第一个元素赋值为 1。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> data<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span>；data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>  <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></code></pre><h3 id="2-栈"><a href="#2-栈" class="headerlink" title="2.栈"></a>2.栈</h3><p>栈是一种特殊的线性表，仅能在线性表的一端操作，栈顶允许操作，栈底不允许操作。 栈的特点是：__先进后出__，或者说是后进先出，从栈顶放入元素的操作叫入栈，取出元素叫出栈。</p><h3 id="3-队列"><a href="#3-队列" class="headerlink" title="3.队列"></a>3.队列</h3><p>队列与栈一样，也是一种线性表，不同的是，队列可以在一端添加元素，在另一端取出元素，也就是：__先进先出__。从一端放入元素的操作称为入队，取出元素为出队，示例图如下：</p><h3 id="4-链表"><a href="#4-链表" class="headerlink" title="4.链表"></a>4.链表</h3><p>链表是物理存储单元上 非连续的、非顺序的 存储结构，数据元素的逻辑顺序是通过链表的指针地址实现，每个元素包含两个结点，一个是存储元素的数据域 (内存空间)，另一个是指向下一个结点地址的指针域。根据指针的指向，链表能形成不同的结构，例如单链表，双向链表，循环链表等。</p><h3 id="5-二叉树"><a href="#5-二叉树" class="headerlink" title="5.二叉树"></a>5.二叉树</h3><p>树是一种数据结构，它是由n个有限节点组成一个具有层次关系的集合。把它叫做 “树” 是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的</p><h3 id="6-堆"><a href="#6-堆" class="headerlink" title="6.堆"></a>6.堆</h3><p>堆这种数据结构其实就是一颗 “完全二叉树”，每个节点的值总是不大于或不小于其父节点的值，即 <strong>大顶堆</strong> or __小顶堆__。</p><h3 id="7-哈希映射"><a href="#7-哈希映射" class="headerlink" title="7.哈希映射"></a>7.哈希映射</h3><p>哈希映射（Hash Map）是根据键值对 (Key value)直接进行访问的数据结构。通过把键值映射到表中一个位置来访问记录，以加快查找的速度，这个映射函数叫做哈希函数，存放记录的数组叫做哈希表。也就是说，使用哈希函数将键映射到存储桶（哈希表）中。这种存储空间可以充分利用数组的查找优势来查找元素，所以查找的速度是最快的。</p><h3 id="8-图"><a href="#8-图" class="headerlink" title="8.图"></a>8.图</h3><p>哈希映射（Hash Map）是根据键值对 (Key value)直接进行访问的数据结构。通过把键值映射到表中一个位置来访问记录，以加快查找的速度，这个映射函数叫做哈希函数，存放记录的数组叫做哈希表。也就是说，使用哈希函数将键映射到存储桶（哈希表）中。这种存储空间可以充分利用数组的查找优势来查找元素，所以查找的速度是最快的。<br>图是一种比较复杂的数据结构，在存储数据上有着比较复杂和高效的算法，分别有邻接矩阵 、邻接表、十字链表、邻接多重表、边集数组等存储结构。</p><p><a href="https://blog.csdn.net/Augurlee/article/details/106769523">ref</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编写高质量代码改善Python程序的 91 个建议</title>
      <link href="/2022/12/14/bian-xie-gao-zhi-liang-dai-ma-gai-shan-python-cheng-xu-de-91-ge-jian-yi/"/>
      <url>/2022/12/14/bian-xie-gao-zhi-liang-dai-ma-gai-shan-python-cheng-xu-de-91-ge-jian-yi/</url>
      
        <content type="html"><![CDATA[<p><a href="https://l1nwatch.gitbook.io/writing_solid_python_code_gitbook/">ref</a></p><h4 id="建议-1：理解-Pythonic-概念"><a href="#建议-1：理解-Pythonic-概念" class="headerlink" title="建议 1：理解 Pythonic 概念"></a>建议 1：理解 Pythonic 概念</h4><h4 id="建议-2：编写-Pythonic-代码"><a href="#建议-2：编写-Pythonic-代码" class="headerlink" title="建议 2：编写 Pythonic 代码"></a>建议 2：编写 Pythonic 代码</h4><h4 id="建议-3：理解-Python-与-C-语言的不同之处"><a href="#建议-3：理解-Python-与-C-语言的不同之处" class="headerlink" title="建议 3：理解 Python 与 C 语言的不同之处"></a>建议 3：理解 Python 与 C 语言的不同之处</h4><h4 id="建议-4：在代码中适当添加注释"><a href="#建议-4：在代码中适当添加注释" class="headerlink" title="建议 4：在代码中适当添加注释"></a>建议 4：在代码中适当添加注释</h4><h4 id="建议-5：通过适当添加空行使代码布局更为优雅、合理"><a href="#建议-5：通过适当添加空行使代码布局更为优雅、合理" class="headerlink" title="建议 5：通过适当添加空行使代码布局更为优雅、合理"></a>建议 5：通过适当添加空行使代码布局更为优雅、合理</h4><h4 id="建议-6：编写函数的几个原则"><a href="#建议-6：编写函数的几个原则" class="headerlink" title="建议 6：编写函数的几个原则"></a>建议 6：编写函数的几个原则</h4><h4 id="建议-7：将常量集中到一个文件"><a href="#建议-7：将常量集中到一个文件" class="headerlink" title="建议 7：将常量集中到一个文件"></a>建议 7：将常量集中到一个文件</h4><h4 id="建议-8：利用-assert-语句来发现问题"><a href="#建议-8：利用-assert-语句来发现问题" class="headerlink" title="建议 8：利用 assert 语句来发现问题"></a>建议 8：利用 assert 语句来发现问题</h4><h4 id="建议-9：数据交换值的时候不推荐使用中间变量"><a href="#建议-9：数据交换值的时候不推荐使用中间变量" class="headerlink" title="建议 9：数据交换值的时候不推荐使用中间变量"></a>建议 9：数据交换值的时候不推荐使用中间变量</h4><h4 id="建议-10：充分利用-Lazy-evaluation-的特性"><a href="#建议-10：充分利用-Lazy-evaluation-的特性" class="headerlink" title="建议 10：充分利用 Lazy evaluation 的特性"></a>建议 10：充分利用 Lazy evaluation 的特性</h4><h4 id="建议-11：理解枚举替代实现的缺陷"><a href="#建议-11：理解枚举替代实现的缺陷" class="headerlink" title="建议 11：理解枚举替代实现的缺陷"></a>建议 11：理解枚举替代实现的缺陷</h4><h4 id="建议-12：不推荐使用-type-来进行类型检查"><a href="#建议-12：不推荐使用-type-来进行类型检查" class="headerlink" title="建议 12：不推荐使用 type 来进行类型检查"></a>建议 12：不推荐使用 type 来进行类型检查</h4><h4 id="建议-13：尽量转换为浮点类型后再做除法"><a href="#建议-13：尽量转换为浮点类型后再做除法" class="headerlink" title="建议 13：尽量转换为浮点类型后再做除法"></a>建议 13：尽量转换为浮点类型后再做除法</h4><h4 id="建议-14：警惕-eval-的安全漏洞"><a href="#建议-14：警惕-eval-的安全漏洞" class="headerlink" title="建议 14：警惕 eval() 的安全漏洞"></a>建议 14：警惕 eval() 的安全漏洞</h4><h4 id="建议-15：使用-enumerate-获取序列迭代的索引和值"><a href="#建议-15：使用-enumerate-获取序列迭代的索引和值" class="headerlink" title="建议 15：使用 enumerate() 获取序列迭代的索引和值"></a>建议 15：使用 enumerate() 获取序列迭代的索引和值</h4><h4 id="建议-16：分清-x3D-x3D-与-is-的适用场景"><a href="#建议-16：分清-x3D-x3D-与-is-的适用场景" class="headerlink" title="建议 16：分清 == 与 is 的适用场景"></a>建议 16：分清 == 与 is 的适用场景</h4><h4 id="建议-17：考虑兼容性，尽可能使用-Unicode"><a href="#建议-17：考虑兼容性，尽可能使用-Unicode" class="headerlink" title="建议 17：考虑兼容性，尽可能使用 Unicode"></a>建议 17：考虑兼容性，尽可能使用 Unicode</h4><h4 id="建议-18：构建合理的包层次来管理-module"><a href="#建议-18：构建合理的包层次来管理-module" class="headerlink" title="建议 18：构建合理的包层次来管理 module"></a>建议 18：构建合理的包层次来管理 module</h4><h4 id="建议-19：有节制地使用-from-…-import-语句"><a href="#建议-19：有节制地使用-from-…-import-语句" class="headerlink" title="建议 19：有节制地使用 from … import 语句"></a>建议 19：有节制地使用 from … import 语句</h4><h4 id="建议-20：优先使用-absolute-import-来导入模块"><a href="#建议-20：优先使用-absolute-import-来导入模块" class="headerlink" title="建议 20：优先使用 absolute import 来导入模块"></a>建议 20：优先使用 absolute import 来导入模块</h4><h4 id="建议-21：i-x3D-1-不等于-i"><a href="#建议-21：i-x3D-1-不等于-i" class="headerlink" title="建议 21：i += 1 不等于 ++i"></a>建议 21：i += 1 不等于 ++i</h4><h4 id="建议-22：使用-with-自动关闭资源"><a href="#建议-22：使用-with-自动关闭资源" class="headerlink" title="建议 22：使用 with 自动关闭资源"></a>建议 22：使用 with 自动关闭资源</h4><h4 id="建议-23：使用-else-子句简化循环（异常处理）"><a href="#建议-23：使用-else-子句简化循环（异常处理）" class="headerlink" title="建议 23：使用 else 子句简化循环（异常处理）"></a>建议 23：使用 else 子句简化循环（异常处理）</h4><h4 id="建议-24：遵循异常处理的几点基本原则"><a href="#建议-24：遵循异常处理的几点基本原则" class="headerlink" title="建议 24：遵循异常处理的几点基本原则"></a>建议 24：遵循异常处理的几点基本原则</h4><p>注意异常的粒度，不推荐在 try 中放入过多的代码。<br>谨慎使用单独的 except 语句处理所有异常，最好能定位具体的异常。<br>注意异常捕获的顺序，在合适的层次处理异常。<br>用户也可以继承自内建异常构建自己的异常类，从而在内建类的继承结构上进一步延伸。<br>使用更为友好的异常信息，遵守异常参数的规范。</p><h4 id="建议-25：避免-finally-中可能发生的陷阱"><a href="#建议-25：避免-finally-中可能发生的陷阱" class="headerlink" title="建议 25：避免 finally 中可能发生的陷阱"></a>建议 25：避免 finally 中可能发生的陷阱</h4><h4 id="建议-26：深入理解-None，正确判断对象是否为空"><a href="#建议-26：深入理解-None，正确判断对象是否为空" class="headerlink" title="建议 26：深入理解 None，正确判断对象是否为空"></a>建议 26：深入理解 None，正确判断对象是否为空</h4><h4 id="建议-27：连接字符串应优先使用-join-而不是"><a href="#建议-27：连接字符串应优先使用-join-而不是" class="headerlink" title="建议 27：连接字符串应优先使用 join 而不是 +"></a>建议 27：连接字符串应优先使用 join 而不是 +</h4><h4 id="建议-28：格式化字符串时尽量使用-format-方式而不是"><a href="#建议-28：格式化字符串时尽量使用-format-方式而不是" class="headerlink" title="建议 28：格式化字符串时尽量使用 .format 方式而不是 %"></a>建议 28：格式化字符串时尽量使用 .format 方式而不是 %</h4><h4 id="建议-29：区别对待可变对象和不可变对象"><a href="#建议-29：区别对待可变对象和不可变对象" class="headerlink" title="建议 29：区别对待可变对象和不可变对象"></a>建议 29：区别对待可变对象和不可变对象</h4><h4 id="建议-30：-、-和-：一致的容器初始化形式"><a href="#建议-30：-、-和-：一致的容器初始化形式" class="headerlink" title="建议 30：[]、() 和 {}：一致的容器初始化形式"></a>建议 30：[]、() 和 {}：一致的容器初始化形式</h4><h4 id="建议-31：记住函数传参既不是传值也不是传引用"><a href="#建议-31：记住函数传参既不是传值也不是传引用" class="headerlink" title="建议 31：记住函数传参既不是传值也不是传引用"></a>建议 31：记住函数传参既不是传值也不是传引用</h4><h4 id="建议-32：警惕默认参数潜在的问题"><a href="#建议-32：警惕默认参数潜在的问题" class="headerlink" title="建议 32：警惕默认参数潜在的问题"></a>建议 32：警惕默认参数潜在的问题</h4><h4 id="建议-33：慎用变长参数"><a href="#建议-33：慎用变长参数" class="headerlink" title="建议 33：慎用变长参数"></a>建议 33：慎用变长参数</h4><h4 id="建议-34：深入理解-str-和-repr-的区别"><a href="#建议-34：深入理解-str-和-repr-的区别" class="headerlink" title="建议 34：深入理解 str() 和 repr() 的区别"></a>建议 34：深入理解 str() 和 repr() 的区别</h4><h4 id="建议-35：分清-staticmethod-和-classmethod-的适用场景"><a href="#建议-35：分清-staticmethod-和-classmethod-的适用场景" class="headerlink" title="建议 35：分清 staticmethod 和 classmethod 的适用场景"></a>建议 35：分清 staticmethod 和 classmethod 的适用场景</h4><h4 id="建议-36：掌握字符串的基本用法"><a href="#建议-36：掌握字符串的基本用法" class="headerlink" title="建议 36：掌握字符串的基本用法"></a>建议 36：掌握字符串的基本用法</h4><h4 id="建议-37：按需选择-sort-或者-sorted"><a href="#建议-37：按需选择-sort-或者-sorted" class="headerlink" title="建议 37：按需选择 sort() 或者 sorted()"></a>建议 37：按需选择 sort() 或者 sorted()</h4><h4 id="建议-38：使用-copy-模块深拷贝对象"><a href="#建议-38：使用-copy-模块深拷贝对象" class="headerlink" title="建议 38：使用 copy 模块深拷贝对象"></a>建议 38：使用 copy 模块深拷贝对象</h4><h4 id="建议-39：使用-Counter-进行计数统计"><a href="#建议-39：使用-Counter-进行计数统计" class="headerlink" title="建议 39：使用 Counter 进行计数统计"></a>建议 39：使用 Counter 进行计数统计</h4><h4 id="建议-40：深入掌握-ConfigParser"><a href="#建议-40：深入掌握-ConfigParser" class="headerlink" title="建议 40：深入掌握 ConfigParser"></a>建议 40：深入掌握 ConfigParser</h4><h4 id="建议-41：使用-argparse-处理命令行参数"><a href="#建议-41：使用-argparse-处理命令行参数" class="headerlink" title="建议 41：使用 argparse 处理命令行参数"></a>建议 41：使用 argparse 处理命令行参数</h4><h4 id="建议-42：使用-pandas-处理大型-CSV-文件"><a href="#建议-42：使用-pandas-处理大型-CSV-文件" class="headerlink" title="建议 42：使用 pandas 处理大型 CSV 文件"></a>建议 42：使用 pandas 处理大型 CSV 文件</h4><h4 id="建议-43：一般情况使用-ElementTree-解析-XML"><a href="#建议-43：一般情况使用-ElementTree-解析-XML" class="headerlink" title="建议 43：一般情况使用 ElementTree 解析 XML"></a>建议 43：一般情况使用 ElementTree 解析 XML</h4><h4 id="建议-44：理解模块-pickle-优劣"><a href="#建议-44：理解模块-pickle-优劣" class="headerlink" title="建议 44：理解模块 pickle 优劣"></a>建议 44：理解模块 pickle 优劣</h4><h4 id="建议-45：序列化的另一个不错的选择——JSON"><a href="#建议-45：序列化的另一个不错的选择——JSON" class="headerlink" title="建议 45：序列化的另一个不错的选择——JSON"></a>建议 45：序列化的另一个不错的选择——JSON</h4><h4 id="建议-46：使用-traceback-获取栈信息"><a href="#建议-46：使用-traceback-获取栈信息" class="headerlink" title="建议 46：使用 traceback 获取栈信息"></a>建议 46：使用 traceback 获取栈信息</h4><h4 id="建议-47：使用-logging-记录日志信息"><a href="#建议-47：使用-logging-记录日志信息" class="headerlink" title="建议 47：使用 logging 记录日志信息"></a>建议 47：使用 logging 记录日志信息</h4><h4 id="建议-48：使用-threading-模块编写多线程程序"><a href="#建议-48：使用-threading-模块编写多线程程序" class="headerlink" title="建议 48：使用 threading 模块编写多线程程序"></a>建议 48：使用 threading 模块编写多线程程序</h4><h4 id="建议-49：使用-Queue-使多线程编程更安全"><a href="#建议-49：使用-Queue-使多线程编程更安全" class="headerlink" title="建议 49：使用 Queue 使多线程编程更安全"></a>建议 49：使用 Queue 使多线程编程更安全</h4><h4 id="建议-50：利用模块实现单例模式"><a href="#建议-50：利用模块实现单例模式" class="headerlink" title="建议 50：利用模块实现单例模式"></a>建议 50：利用模块实现单例模式</h4><h4 id="建议-51：用-mixin-模式让程序更加灵活"><a href="#建议-51：用-mixin-模式让程序更加灵活" class="headerlink" title="建议 51：用 mixin 模式让程序更加灵活"></a>建议 51：用 mixin 模式让程序更加灵活</h4><h4 id="建议-52：用发布订阅模式实现松耦合"><a href="#建议-52：用发布订阅模式实现松耦合" class="headerlink" title="建议 52：用发布订阅模式实现松耦合"></a>建议 52：用发布订阅模式实现松耦合</h4><h4 id="建议-53：用状态模式美化代码"><a href="#建议-53：用状态模式美化代码" class="headerlink" title="建议 53：用状态模式美化代码"></a>建议 53：用状态模式美化代码</h4><h4 id="建议-54：理解-built-in-objects"><a href="#建议-54：理解-built-in-objects" class="headerlink" title="建议 54：理解 built-in objects"></a>建议 54：理解 built-in objects</h4><h4 id="建议-55：init-不是构造方法"><a href="#建议-55：init-不是构造方法" class="headerlink" title="建议 55：init() 不是构造方法"></a>建议 55：<strong>init</strong>() 不是构造方法</h4><h4 id="建议-56：理解名字查找机制"><a href="#建议-56：理解名字查找机制" class="headerlink" title="建议 56：理解名字查找机制"></a>建议 56：理解名字查找机制</h4><h4 id="建议-57：为什么需要-self-参数"><a href="#建议-57：为什么需要-self-参数" class="headerlink" title="建议 57：为什么需要 self 参数"></a>建议 57：为什么需要 self 参数</h4><h4 id="建议-58：理解-MRO-与多继承"><a href="#建议-58：理解-MRO-与多继承" class="headerlink" title="建议 58：理解 MRO 与多继承"></a>建议 58：理解 MRO 与多继承</h4><h4 id="建议-59：理解描述符机制"><a href="#建议-59：理解描述符机制" class="headerlink" title="建议 59：理解描述符机制"></a>建议 59：理解描述符机制</h4><h4 id="建议-60：区别-getattr-和-getattribute-方法"><a href="#建议-60：区别-getattr-和-getattribute-方法" class="headerlink" title="建议 60：区别 getattr() 和 getattribute() 方法"></a>建议 60：区别 <strong>getattr</strong>() 和 <strong>getattribute</strong>() 方法</h4><h4 id="建议-61：使用更为安全的-property"><a href="#建议-61：使用更为安全的-property" class="headerlink" title="建议 61：使用更为安全的 property"></a>建议 61：使用更为安全的 property</h4><h4 id="建议-62：掌握-metaclass"><a href="#建议-62：掌握-metaclass" class="headerlink" title="建议 62：掌握 metaclass"></a>建议 62：掌握 metaclass</h4><h4 id="建议-63：熟悉-Python-对象协议"><a href="#建议-63：熟悉-Python-对象协议" class="headerlink" title="建议 63：熟悉 Python 对象协议"></a>建议 63：熟悉 Python 对象协议</h4><h4 id="建议-64：使用操作符重载实现中缀语法"><a href="#建议-64：使用操作符重载实现中缀语法" class="headerlink" title="建议 64：使用操作符重载实现中缀语法"></a>建议 64：使用操作符重载实现中缀语法</h4><h4 id="建议-65：熟悉-Python-的迭代器协议"><a href="#建议-65：熟悉-Python-的迭代器协议" class="headerlink" title="建议 65：熟悉 Python 的迭代器协议"></a>建议 65：熟悉 Python 的迭代器协议</h4><h4 id="建议-66：熟悉-Python-的生成器"><a href="#建议-66：熟悉-Python-的生成器" class="headerlink" title="建议 66：熟悉 Python 的生成器"></a>建议 66：熟悉 Python 的生成器</h4><h4 id="建议-67：基于生成器的协程及-greenlet"><a href="#建议-67：基于生成器的协程及-greenlet" class="headerlink" title="建议 67：基于生成器的协程及 greenlet"></a>建议 67：基于生成器的协程及 greenlet</h4><h4 id="建议-68：理解-GIL-的局限性"><a href="#建议-68：理解-GIL-的局限性" class="headerlink" title="建议 68：理解 GIL 的局限性"></a>建议 68：理解 GIL 的局限性</h4><h4 id="建议-69：对象的管理与垃圾回收"><a href="#建议-69：对象的管理与垃圾回收" class="headerlink" title="建议 69：对象的管理与垃圾回收"></a>建议 69：对象的管理与垃圾回收</h4><h4 id="建议-70：从-PyPI-安装包"><a href="#建议-70：从-PyPI-安装包" class="headerlink" title="建议 70：从 PyPI 安装包"></a>建议 70：从 PyPI 安装包</h4><h4 id="建议-71：使用-pip-和-yolk-安装、管理包"><a href="#建议-71：使用-pip-和-yolk-安装、管理包" class="headerlink" title="建议 71：使用 pip 和 yolk 安装、管理包"></a>建议 71：使用 pip 和 yolk 安装、管理包</h4><h4 id="建议-72：做-paster-创建包"><a href="#建议-72：做-paster-创建包" class="headerlink" title="建议 72：做 paster 创建包"></a>建议 72：做 paster 创建包</h4><h4 id="建议-73：理解单元测试概念"><a href="#建议-73：理解单元测试概念" class="headerlink" title="建议 73：理解单元测试概念"></a>建议 73：理解单元测试概念</h4><h4 id="建议-74：为包编写单元测试"><a href="#建议-74：为包编写单元测试" class="headerlink" title="建议 74：为包编写单元测试"></a>建议 74：为包编写单元测试</h4><h4 id="建议-75：利用测试驱动开发提高代码的可测性"><a href="#建议-75：利用测试驱动开发提高代码的可测性" class="headerlink" title="建议 75：利用测试驱动开发提高代码的可测性"></a>建议 75：利用测试驱动开发提高代码的可测性</h4><h4 id="建议-76：使用-Pylint-检查代码风格"><a href="#建议-76：使用-Pylint-检查代码风格" class="headerlink" title="建议 76：使用 Pylint 检查代码风格"></a>建议 76：使用 Pylint 检查代码风格</h4><h4 id="建议-77：进行高效的代码审查"><a href="#建议-77：进行高效的代码审查" class="headerlink" title="建议 77：进行高效的代码审查"></a>建议 77：进行高效的代码审查</h4><h4 id="建议-78：将包发布到-PyPI"><a href="#建议-78：将包发布到-PyPI" class="headerlink" title="建议 78：将包发布到 PyPI"></a>建议 78：将包发布到 PyPI</h4><h4 id="建议-79：了解代码优化的基本原则"><a href="#建议-79：了解代码优化的基本原则" class="headerlink" title="建议 79：了解代码优化的基本原则"></a>建议 79：了解代码优化的基本原则</h4><h4 id="建议-80：借助性能优化工具"><a href="#建议-80：借助性能优化工具" class="headerlink" title="建议 80：借助性能优化工具"></a>建议 80：借助性能优化工具</h4><h4 id="建议-81：利用-cProfile-定位性能瓶颈"><a href="#建议-81：利用-cProfile-定位性能瓶颈" class="headerlink" title="建议 81：利用 cProfile 定位性能瓶颈"></a>建议 81：利用 cProfile 定位性能瓶颈</h4><h4 id="建议-82：使用-memory-profiler-和-objgraph-剖析内存使用"><a href="#建议-82：使用-memory-profiler-和-objgraph-剖析内存使用" class="headerlink" title="建议 82：使用 memory_profiler 和 objgraph 剖析内存使用"></a>建议 82：使用 memory_profiler 和 objgraph 剖析内存使用</h4><h4 id="建议-83：努力降低算法复杂度"><a href="#建议-83：努力降低算法复杂度" class="headerlink" title="建议 83：努力降低算法复杂度"></a>建议 83：努力降低算法复杂度</h4><h4 id="建议-84：掌握循环优化的基本技巧"><a href="#建议-84：掌握循环优化的基本技巧" class="headerlink" title="建议 84：掌握循环优化的基本技巧"></a>建议 84：掌握循环优化的基本技巧</h4><h4 id="建议-85：使用生成器提高效率"><a href="#建议-85：使用生成器提高效率" class="headerlink" title="建议 85：使用生成器提高效率"></a>建议 85：使用生成器提高效率</h4><h4 id="建议-86：使用不同的数据结构优化性能"><a href="#建议-86：使用不同的数据结构优化性能" class="headerlink" title="建议 86：使用不同的数据结构优化性能"></a>建议 86：使用不同的数据结构优化性能</h4><h4 id="建议-87：充分利用-set-的优势"><a href="#建议-87：充分利用-set-的优势" class="headerlink" title="建议 87：充分利用 set 的优势"></a>建议 87：充分利用 set 的优势</h4><h4 id="建议-88：使用-multiprocess-克服-GIL-的缺陷"><a href="#建议-88：使用-multiprocess-克服-GIL-的缺陷" class="headerlink" title="建议 88：使用 multiprocess 克服 GIL 的缺陷"></a>建议 88：使用 multiprocess 克服 GIL 的缺陷</h4><h4 id="建议-89：使用线程池提高效率"><a href="#建议-89：使用线程池提高效率" class="headerlink" title="建议 89：使用线程池提高效率"></a>建议 89：使用线程池提高效率</h4><h4 id="建议-90：使用-C-x2F-C-模块扩展高性能"><a href="#建议-90：使用-C-x2F-C-模块扩展高性能" class="headerlink" title="建议 90：使用 C/C++ 模块扩展高性能"></a>建议 90：使用 C/C++ 模块扩展高性能</h4><h4 id="建议-91：使用-Cython-编写扩展模块"><a href="#建议-91：使用-Cython-编写扩展模块" class="headerlink" title="建议 91：使用 Cython 编写扩展模块"></a>建议 91：使用 Cython 编写扩展模块</h4>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++函数返回多值方法</title>
      <link href="/2022/12/12/c-han-shu-fan-hui-duo-zhi-zong-jie/"/>
      <url>/2022/12/12/c-han-shu-fan-hui-duo-zhi-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>用惯了Python，才发现c++函数默认是返回一个值/无返回值…<br>但是这怎么能难道聪明的工程师们，下面总结几个c++常用的返回多值办法，std::pair在此不讨论，因为他只能返回两个值…</p><p><a href="https://blog.csdn.net/qq_43685921/article/details/123854007">C++函数返回多个值：结构体、tuple</a><br><a href="https://www.geeksforgeeks.org/returning-multiple-values-from-a-function-using-tuple-and-pair-in-c/">Returning multiple values from a function using Tuple and Pair in C++</a></p><h3 id="使用tuple返回多个值"><a href="#使用tuple返回多个值" class="headerlink" title="使用tuple返回多个值"></a>使用tuple返回多个值</h3><p>相比于结构体，要实现函数返回多个值的方法，使用tuple更为简洁、灵活。<br>实现步骤：<br>1.定义函数f(x):类型为tuple<br>2.函数返回多个值:使用make_tuple(result1,result2,…)<br>3.使用函数结果：result=f(x)<br>4.取函数返回值：result1=get&lt;0&gt;(result)； result2=get&lt;1&gt;(result);</p><pre class=" language-cpp"><code class="language-cpp">tuple<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">></span>  <span class="token function">filterFloorPoint</span><span class="token punctuation">(</span> <span class="token keyword">int</span> max_iterations<span class="token punctuation">,</span><span class="token keyword">float</span> in_floor_max_angle<span class="token punctuation">,</span><span class="token keyword">float</span> Distance_Threshold<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> result_iterations<span class="token punctuation">;</span>    <span class="token keyword">float</span> result_angle_add_distance<span class="token punctuation">;</span>    result_iterations<span class="token operator">=</span>max_iterations<span class="token operator">*</span><span class="token number">100</span><span class="token punctuation">;</span>    result_angle_add_distance<span class="token operator">=</span>in_floor_max_angle<span class="token operator">*</span>Distance_Threshold<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//此时，我们想要函数返回result_iterations和result_angle_add_distance两个值</span><span class="token comment" spellcheck="true">//使用make_tuple将要返回的数据写在()里面即可，注意数据类型的顺序</span>    <span class="token keyword">return</span> <span class="token function">make_tuple</span><span class="token punctuation">(</span>result_iterations<span class="token punctuation">,</span>result_angle_add_distance<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> max_iterations<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> in_floor_max_angle<span class="token operator">=</span><span class="token number">10.0</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> Distance_Threshold<span class="token operator">=</span><span class="token number">10.0</span><span class="token punctuation">;</span>        tuple<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">></span>  get_filterFloorPoint_result<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//调用 filterFloorPoint 方法</span>    get_filterFloorPoint_result<span class="token operator">=</span><span class="token function">filterFloorPoint</span><span class="token punctuation">(</span>max_iterations<span class="token punctuation">,</span>in_floor_max_angle<span class="token punctuation">,</span>Distance_Threshold<span class="token punctuation">)</span><span class="token punctuation">;</span>    without_floor_cloud_ptr<span class="token operator">=</span>get<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">></span><span class="token punctuation">(</span>get_filterFloorPoint_result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//取第一个值</span>    only_floor_cloud_ptr<span class="token operator">=</span>get<span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">></span><span class="token punctuation">(</span>get_filterFloorPoint_result<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//取第二个值</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>另一个例子(对比pair和tuple)</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// A Method that returns multiple values using</span><span class="token comment" spellcheck="true">// tuple in C++.</span>tuple<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">></span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> n1<span class="token punctuation">,</span> <span class="token keyword">int</span> n2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Packing values to return a tuple</span>    <span class="token keyword">return</span> <span class="token function">make_tuple</span><span class="token punctuation">(</span>n2<span class="token punctuation">,</span> n1<span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// A Method returns a pair of values using pair</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> <span class="token function">foo1</span><span class="token punctuation">(</span><span class="token keyword">int</span> num1<span class="token punctuation">,</span> <span class="token keyword">int</span> num2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Packing two values to return a pair </span>    <span class="token keyword">return</span> <span class="token function">make_pair</span><span class="token punctuation">(</span>num2<span class="token punctuation">,</span> num1<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>  <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">,</span>b<span class="token punctuation">;</span>    <span class="token keyword">char</span> cc<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// Unpack the elements returned by foo</span>    <span class="token function">tie</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> cc<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// Storing  returned values in a pair </span>    pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> p <span class="token operator">=</span> <span class="token function">foo1</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Values returned by tuple: "</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> cc <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>          cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Values returned by Pair: "</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">.</span>first <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">.</span>second<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>其中，<code>#include&lt;bits/stdc++.h&gt;</code> 是一个万能头文件，包含了绝大多数常用的头文件！</p><h3 id="使用结构体返回多个值"><a href="#使用结构体返回多个值" class="headerlink" title="使用结构体返回多个值"></a>使用结构体返回多个值</h3><p>实现步骤：<br>1.先定义一个结构体<br>2.准备我们要实现的函数(需要返回多个值)<br>3.在要实现的函数内调用结构体返回多个值<br>4.使用函数返回结果</p><pre class=" language-cpp"><code class="language-cpp">step <span class="token number">1</span> <span class="token operator">:</span>定义结构体 <span class="token keyword">struct</span>  PointStruct<span class="token punctuation">{</span>    <span class="token keyword">float</span> without_floor<span class="token punctuation">;</span>    <span class="token keyword">int</span> only_floor<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><pre class=" language-cpp"><code class="language-cpp">step <span class="token number">2</span> <span class="token operator">:</span>定义函数 <span class="token comment" spellcheck="true">//定义了一个返回值为PointStruct的函数，函数名为filterFloorPoint</span>PointStruct <span class="token function">filterFloorPoint</span><span class="token punctuation">(</span> <span class="token keyword">int</span> max_iterations<span class="token punctuation">,</span><span class="token keyword">float</span> in_floor_max_angle<span class="token punctuation">,</span><span class="token keyword">float</span> Distance_Threshold<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> result_iterations<span class="token punctuation">;</span>    <span class="token keyword">float</span> result_angle_add_distance<span class="token punctuation">;</span>    result_iterations<span class="token operator">=</span>max_iterations<span class="token operator">*</span><span class="token number">100</span><span class="token punctuation">;</span>    result_angle_add_distance<span class="token operator">=</span>in_floor_max_angle<span class="token operator">*</span>Distance_Threshold<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//此时，我们想要函数返回result_iterations和result_angle_add_distance两个值</span>    <span class="token comment" spellcheck="true">//step 3:调用结构体返回多个值 </span>    <span class="token comment" spellcheck="true">//调用PointStruct结构体返回多个值 </span>    PointStruct use_PointStruct<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//use_PointStruct 可以换成你自己想要的名称</span>    use_PointStruct<span class="token punctuation">.</span>without_floor<span class="token operator">=</span>result_iterations<span class="token punctuation">;</span>    use_PointStruct<span class="token punctuation">.</span>only_floor<span class="token operator">=</span>result_angle_add_distance<span class="token punctuation">;</span>    <span class="token keyword">return</span> use_PointStruct<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//只需要返回 use_PointStruct即可</span><span class="token punctuation">}</span></code></pre><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//step 4:调用结构体返回的多个值</span>    <span class="token keyword">int</span> max_iterations<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> in_floor_max_angle<span class="token operator">=</span><span class="token number">10.0</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> Distance_Threshold<span class="token operator">=</span><span class="token number">10.0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> without_floor_cloud_ptr<span class="token punctuation">;</span>    <span class="token keyword">float</span> only_floor_cloud_ptr<span class="token punctuation">;</span>      PointStruct  use_PointStruct_now<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//调用PointStruct结构体</span>         use_PointStruct_now<span class="token operator">=</span><span class="token function">filterFloorPoint</span><span class="token punctuation">(</span>max_iterations<span class="token punctuation">,</span>in_floor_max_angle<span class="token punctuation">,</span>Distance_Threshold<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//调用函数</span>     without_floor_cloud_ptr<span class="token operator">=</span>use_PointStruct_now<span class="token punctuation">.</span>without_floor<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//取第一个函数返回值</span>     only_floor_cloud_ptr<span class="token operator">=</span>use_PointStruct_now<span class="token punctuation">.</span>only_floor<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//取第二个函数返回值</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使Python运行更快</title>
      <link href="/2022/12/12/ru-he-shi-python-yun-xing-geng-kuai/"/>
      <url>/2022/12/12/ru-he-shi-python-yun-xing-geng-kuai/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/267531379">ref</a></p><h3 id="避免全局变量-记得使用main函数"><a href="#避免全局变量-记得使用main函数" class="headerlink" title="避免全局变量 (记得使用main函数)"></a>避免全局变量 (记得使用main函数)</h3><p>这种写法耗时5.35s</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> mathtime_start<span class="token operator">=</span>time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>size <span class="token operator">=</span> <span class="token number">5000</span><span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> y <span class="token keyword">in</span> range<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>        z <span class="token operator">=</span> math<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">+</span> math<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>y<span class="token punctuation">)</span>time_end<span class="token operator">=</span>time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'time cost'</span><span class="token punctuation">,</span>time_end<span class="token operator">-</span>time_start<span class="token punctuation">,</span><span class="token string">'s'</span><span class="token punctuation">)</span></code></pre><p>许多程序员刚开始会用 Python 语言写一些简单的脚本，当编写脚本时，通常习惯了直接将其写为全局变量，例如上面的代码。但是，由于全局变量和局部变量实现方式不同，定义在全局范围内的代码运行速度会比定义在函数中的慢不少。通过将脚本语句放入到函数中，通常可带来 15% - 30% 的速度提升。</p><p>这种写法耗时4.83s</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> math<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 定义到函数中，以减少全部变量使用</span>    size <span class="token operator">=</span> <span class="token number">5000</span>    time_start<span class="token operator">=</span>time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> y <span class="token keyword">in</span> range<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>            z <span class="token operator">=</span> math<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">+</span> math<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>y<span class="token punctuation">)</span>        time_end<span class="token operator">=</span>time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'time cost'</span><span class="token punctuation">,</span>time_end<span class="token operator">-</span>time_start<span class="token punctuation">,</span><span class="token string">'s'</span><span class="token punctuation">)</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="避免-（属性访问操作符）"><a href="#避免-（属性访问操作符）" class="headerlink" title="避免.（属性访问操作符）"></a>避免.（属性访问操作符）</h3><h4 id="避免模块和函数属性访问"><a href="#避免模块和函数属性访问" class="headerlink" title="避免模块和函数属性访问"></a>避免模块和函数属性访问</h4><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 不推荐写法。代码耗时3.20s</span><span class="token keyword">import</span> math<span class="token keyword">def</span> <span class="token function">computeSqrt</span><span class="token punctuation">(</span>size<span class="token punctuation">:</span> int<span class="token punctuation">)</span><span class="token punctuation">:</span>    result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>        result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>math<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> result<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    size <span class="token operator">=</span> <span class="token number">10000</span>    <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>        result <span class="token operator">=</span> computeSqrt<span class="token punctuation">(</span>size<span class="token punctuation">)</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>上面的代码有几个问题：</p><ol><li>每次使用.（属性访问操作符时）会触发特定的方法，如__getattribute__()和__getattr__()，这些方法会进行字典操作，因此会带来额外的时间开销。通过from import语句，可以消除属性访问</li><li>局部变量的查找会比全局变量更快，因此对于频繁访问的变量sqrt，通过将其改为局部变量可以加速运行</li><li>除了math.sqrt外，computeSqrt函数中还有.的存在，那就是调用list的append方法。通过将该方法赋值给一个局部变量，可以彻底消除computeSqrt函数中for循环内部的.使用。</li></ol><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 推荐写法。代码耗时1.98s</span><span class="token keyword">import</span> math<span class="token keyword">def</span> <span class="token function">computeSqrt</span><span class="token punctuation">(</span>size<span class="token punctuation">:</span> int<span class="token punctuation">)</span><span class="token punctuation">:</span>    result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    append <span class="token operator">=</span> result<span class="token punctuation">.</span>append    sqrt <span class="token operator">=</span> math<span class="token punctuation">.</span>sqrt    <span class="token comment" spellcheck="true"># 赋值给局部变量</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>        append<span class="token punctuation">(</span>sqrt<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 避免 result.append 和 math.sqrt 的使用</span>    <span class="token keyword">return</span> result<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    size <span class="token operator">=</span> <span class="token number">10000</span>    <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>        result <span class="token operator">=</span> computeSqrt<span class="token punctuation">(</span>size<span class="token punctuation">)</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h4 id="避免类内属性访问"><a href="#避免类内属性访问" class="headerlink" title="避免类内属性访问"></a>避免类内属性访问</h4><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 不推荐写法。代码耗时：10.4秒</span><span class="token keyword">import</span> math<span class="token keyword">from</span> typing <span class="token keyword">import</span> List<span class="token keyword">class</span> <span class="token class-name">DemoClass</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">:</span> int<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>_value <span class="token operator">=</span> value        <span class="token keyword">def</span> <span class="token function">computeSqrt</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> size<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>float<span class="token punctuation">]</span><span class="token punctuation">:</span>        result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        append <span class="token operator">=</span> result<span class="token punctuation">.</span>append        sqrt <span class="token operator">=</span> math<span class="token punctuation">.</span>sqrt        <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>            append<span class="token punctuation">(</span>sqrt<span class="token punctuation">(</span>self<span class="token punctuation">.</span>_value<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> result<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    size <span class="token operator">=</span> <span class="token number">10000</span>    <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>        demo_instance <span class="token operator">=</span> DemoClass<span class="token punctuation">(</span>size<span class="token punctuation">)</span>        result <span class="token operator">=</span> demo_instance<span class="token punctuation">.</span>computeSqrt<span class="token punctuation">(</span>size<span class="token punctuation">)</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>避免.的原则也适用于类内属性，访问self._value的速度会比访问一个局部变量更慢一些。通过将需要频繁访问的类内属性赋值给一个局部变量，可以提升代码运行速度。</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 推荐写法。代码耗时：8.0秒</span><span class="token keyword">import</span> math<span class="token keyword">from</span> typing <span class="token keyword">import</span> List<span class="token keyword">class</span> <span class="token class-name">DemoClass</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">:</span> int<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>_value <span class="token operator">=</span> value        <span class="token keyword">def</span> <span class="token function">computeSqrt</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> size<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>float<span class="token punctuation">]</span><span class="token punctuation">:</span>        result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        append <span class="token operator">=</span> result<span class="token punctuation">.</span>append        sqrt <span class="token operator">=</span> math<span class="token punctuation">.</span>sqrt        value <span class="token operator">=</span> self<span class="token punctuation">.</span>_value        <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>            append<span class="token punctuation">(</span>sqrt<span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 避免 self._value 的使用</span>        <span class="token keyword">return</span> result<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    size <span class="token operator">=</span> <span class="token number">10000</span>    <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>        demo_instance <span class="token operator">=</span> DemoClass<span class="token punctuation">(</span>size<span class="token punctuation">)</span>        demo_instance<span class="token punctuation">.</span>computeSqrt<span class="token punctuation">(</span>size<span class="token punctuation">)</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="避免数据复制"><a href="#避免数据复制" class="headerlink" title="避免数据复制"></a>避免数据复制</h3><h4 id="避免无意义的数据复制"><a href="#避免无意义的数据复制" class="headerlink" title="避免无意义的数据复制"></a>避免无意义的数据复制</h4><h4 id="交换值时不使用中间变量"><a href="#交换值时不使用中间变量" class="headerlink" title="交换值时不使用中间变量"></a>交换值时不使用中间变量</h4><p>有些代码在交换值时创建了一个临时变量temp，如果不借助中间变量，代码更为简洁、且运行速度更快。</p><h4 id="字符串拼接用join而不是"><a href="#字符串拼接用join而不是" class="headerlink" title="字符串拼接用join而不是+"></a>字符串拼接用join而不是+</h4><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 不推荐写法，代码耗时：2.6秒</span><span class="token keyword">import</span> string<span class="token keyword">from</span> typing <span class="token keyword">import</span> List<span class="token keyword">def</span> <span class="token function">concatString</span><span class="token punctuation">(</span>string_list<span class="token punctuation">:</span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>    result <span class="token operator">=</span> <span class="token string">''</span>    <span class="token keyword">for</span> str_i <span class="token keyword">in</span> string_list<span class="token punctuation">:</span>        result <span class="token operator">+=</span> str_i    <span class="token keyword">return</span> result<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    string_list <span class="token operator">=</span> list<span class="token punctuation">(</span>string<span class="token punctuation">.</span>ascii_letters <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        result <span class="token operator">=</span> concatString<span class="token punctuation">(</span>string_list<span class="token punctuation">)</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>当使用a + b拼接字符串时，由于 Python 中字符串是不可变对象，其会申请一块内存空间，将a和b分别复制到该新申请的内存空间中。而使用join()拼接字符串时，会首先计算出需要申请的总的内存空间，然后一次性地申请所需内存，并将每个字符串元素复制到该内存中去。</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 推荐写法，代码耗时：0.3秒</span><span class="token keyword">import</span> string<span class="token keyword">from</span> typing <span class="token keyword">import</span> List<span class="token keyword">def</span> <span class="token function">concatString</span><span class="token punctuation">(</span>string_list<span class="token punctuation">:</span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>string_list<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 使用 join 而不是 +</span><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    string_list <span class="token operator">=</span> list<span class="token punctuation">(</span>string<span class="token punctuation">.</span>ascii_letters <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        result <span class="token operator">=</span> concatString<span class="token punctuation">(</span>string_list<span class="token punctuation">)</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h4 id="利用if条件的短路特性"><a href="#利用if条件的短路特性" class="headerlink" title="利用if条件的短路特性"></a>利用if条件的短路特性</h4><p>if 条件的短路特性是指对if a and b这样的语句， 当a为False时将直接返回，不再计算b；对于if a or b这样的语句，当a为True时将直接返回，不再计算b。因此， 为了节约运行时间，对于or语句，应该将值为True可能性比较高的变量写在or前，而and应该推后。</p><h3 id="循环优化"><a href="#循环优化" class="headerlink" title="循环优化"></a>循环优化</h3><h4 id="用for循环代替while循环"><a href="#用for循环代替while循环" class="headerlink" title="用for循环代替while循环"></a>用for循环代替while循环</h4><h4 id="使用隐式for循环代替显式for循环"><a href="#使用隐式for循环代替显式for循环" class="headerlink" title="使用隐式for循环代替显式for循环"></a>使用隐式for循环代替显式for循环</h4><h4 id="减少内层for循环的计算"><a href="#减少内层for循环的计算" class="headerlink" title="减少内层for循环的计算"></a>减少内层for循环的计算</h4><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 不推荐写法。代码耗时：12.8秒</span><span class="token keyword">import</span> math<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    size <span class="token operator">=</span> <span class="token number">10000</span>    sqrt <span class="token operator">=</span> math<span class="token punctuation">.</span>sqrt    <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> y <span class="token keyword">in</span> range<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>            z <span class="token operator">=</span> sqrt<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">+</span> sqrt<span class="token punctuation">(</span>y<span class="token punctuation">)</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>上面的代码中sqrt(x)位于内侧for循环， 每次训练过程中都会重新计算一次，增加了时间开销。</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 推荐写法。代码耗时：7.0秒</span><span class="token keyword">import</span> math<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    size <span class="token operator">=</span> <span class="token number">10000</span>    sqrt <span class="token operator">=</span> math<span class="token punctuation">.</span>sqrt    <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>        sqrt_x <span class="token operator">=</span> sqrt<span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 减少内层 for 循环的计算</span>        <span class="token keyword">for</span> y <span class="token keyword">in</span> range<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>            z <span class="token operator">=</span> sqrt_x <span class="token operator">+</span> sqrt<span class="token punctuation">(</span>y<span class="token punctuation">)</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="选择合适的数据结构"><a href="#选择合适的数据结构" class="headerlink" title="选择合适的数据结构"></a>选择合适的数据结构</h3><p>Python 内置的数据结构如str, tuple, list, set, dict底层都是 C 实现的，速度非常快，自己实现新的数据结构想在性能上达到内置的速度几乎是不可能的。</p><p>list类似于 C++ 中的std::vector，是一种动态数组。其会预分配一定内存空间，当预分配的内存空间用完，又继续向其中添加元素时，会申请一块更大的内存空间，然后将原有的所有元素都复制过去，之后销毁之前的内存空间，再插入新元素。删除元素时操作类似，当已使用内存空间比预分配内存空间的一半还少时，会另外申请一块小内存，做一次元素复制，之后销毁原有大内存空间。因此，如果有频繁的新增、删除操作，新增、删除的元素数量又很多时，list的效率不高。此时，应该考虑使用collections.deque。collections.deque是双端队列，同时具备栈和队列的特性，能够在两端进行 复杂度的插入和删除操作。</p><p>list的查找操作也非常耗时。当需要在list频繁查找某些元素，或频繁有序访问这些元素时，可以使用bisect维护list对象有序并在其中进行二分查找，提升查找的效率。</p><p>另外一个常见需求是查找极小值或极大值，此时可以使用heapq模块将list转化为一个堆，使得获取最小值的时间复杂度是 。</p><p><a href="https://zhuanlan.zhihu.com/p/267531379">ref</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google开源项目风格指南——Python风格规范</title>
      <link href="/2022/12/08/python-feng-ge-gui-fan/"/>
      <url>/2022/12/08/python-feng-ge-gui-fan/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/contents/">Python风格指南(中文版)</a></p><h3 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h3><p>如果你先学习了c++，记得不要在行尾加分号，也不要用分号将两条命令放在同一行</p><h3 id="行长度"><a href="#行长度" class="headerlink" title="行长度"></a>行长度</h3><p>每行不超过80个字符。<br>但是：url/路径等不要分割</p><pre class=" language-python"><code class="language-python">Yes<span class="token punctuation">:</span> foo_bar<span class="token punctuation">(</span>self<span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'black'</span><span class="token punctuation">,</span> design<span class="token operator">=</span>None<span class="token punctuation">,</span> x<span class="token operator">=</span><span class="token string">'foo'</span><span class="token punctuation">,</span>             emphasis<span class="token operator">=</span>None<span class="token punctuation">,</span> highlight<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>width <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">and</span> height <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">and</span>         color <span class="token operator">==</span> <span class="token string">'red'</span> <span class="token operator">and</span> emphasis <span class="token operator">==</span> <span class="token string">'strong'</span><span class="token punctuation">)</span><span class="token punctuation">:</span></code></pre><pre class=" language-python"><code class="language-python">Yes<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># See details at</span>      <span class="token comment" spellcheck="true"># http://www.example.com/us/developer/documentation/api/content/v2.0/csv_file_name_extension_full_specification.html</span>No<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># See details at</span>     <span class="token comment" spellcheck="true"># http://www.example.com/us/developer/documentation/api/content/\</span>     <span class="token comment" spellcheck="true"># v2.0/csv_file_name_extension_full_specification.html</span></code></pre><h3 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h3><p><strong>宁缺毋滥</strong></p><h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><p><strong>用4个空格来缩进代码</strong><br>绝对不要用tab, 也不要tab和空格混用. 建议使用4空格的悬挂式缩进</p><h3 id="序列元素尾部逗号"><a href="#序列元素尾部逗号" class="headerlink" title="序列元素尾部逗号"></a>序列元素尾部逗号</h3><pre class=" language-python"><code class="language-python">Yes<span class="token punctuation">:</span>   golomb3 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>Yes<span class="token punctuation">:</span>   golomb4 <span class="token operator">=</span> <span class="token punctuation">[</span>           <span class="token number">0</span><span class="token punctuation">,</span>           <span class="token number">1</span><span class="token punctuation">,</span>           <span class="token number">4</span><span class="token punctuation">,</span>           <span class="token number">6</span><span class="token punctuation">,</span>       <span class="token punctuation">]</span>No<span class="token punctuation">:</span>    golomb4 <span class="token operator">=</span> <span class="token punctuation">[</span>           <span class="token number">0</span><span class="token punctuation">,</span>           <span class="token number">1</span><span class="token punctuation">,</span>           <span class="token number">4</span><span class="token punctuation">,</span>           <span class="token number">6</span>       <span class="token punctuation">]</span></code></pre><h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h3><p>顶级定义之间空两行, 比如函数或者类定义. 方法定义, 类定义与第一个方法之间, 都应该空一行. 函数或方法中, 某些地方要是你觉得合适, 就空一行.</p><h3 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h3><p>括号内不要有空格<br>不要在逗号, 分号, 冒号前面加空格, 但应该在它们后面加(除了在行尾)<br>参数列表, 索引或切片的左括号前不应加空格<br>……</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>参考《编写可读代码的艺术》</p><h3 id="标点符号-拼写和语法"><a href="#标点符号-拼写和语法" class="headerlink" title="标点符号,拼写和语法"></a>标点符号,拼写和语法</h3><p>注意标点符号,拼写和语法</p><p>注释应有适当的大写和标点,句子应该尽量完整.对于诸如在行尾上的较短注释,可以不那么正式,但是也应该尽量保持风格一致</p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>如果一个类不继承自其它类, 就显式的从object继承. 嵌套类也一样.(除非是为了和 python2 兼容)</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>避免在循环中用+和+=操作符来累加字符串. 由于字符串是不可变的, 这样做会创建不必要的临时对象, 并且导致二次方而不是线性的运行时间. 作为替代方案, 你可以将每个子串加入列表, 然后在循环结束后用 <code>.join</code> 连接列表. (也可以将每个子串写入一个 <code>cStringIO.StringIO</code> 缓存中.)</p><p>为多行字符串使用三重双引号”””而非三重单引号’’’. </p><h3 id="文件和sockets"><a href="#文件和sockets" class="headerlink" title="文件和sockets"></a>文件和sockets</h3><p><strong>在文件和sockets结束时, 显式的关闭它</strong></p><h3 id="TODO注释"><a href="#TODO注释" class="headerlink" title="TODO注释"></a>TODO注释</h3><p>为临时代码使用TODO注释, 它是一种短期解决方案. 不算完美, 但够好了.</p><h3 id="导入格式"><a href="#导入格式" class="headerlink" title="导入格式"></a>导入格式</h3><p>每个导入应该独占一行, <code>typing</code> 的导入除外</p><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>通常每个语句应该独占一行</p><p>不过, 如果测试结果与测试语句在一行放得下, 你也可以将它们放在同一行. 如果是if语句, 只有在没有else时才能这样做</p><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><p>模块名写法: module_name ;<br>包名写法: package_name ;<br>类名: ClassName ;<br>方法名: method_name ;<br>异常名: ExceptionName ;<br>函数名: function_name ;<br>全局常量名: GLOBAL_CONSTANT_NAME ;<br>全局变量名: global_var_name ;<br>实例名: instance_var_name ;<br>函数参数名: function_parameter_name ;<br>局部变量名: local_var_name</p><p>函数名,变量名和文件名应该是描述性的,尽量避免缩写,特别要避免使用非项目人员不清楚难以理解的缩写,不要通过删除单词中的字母来进行缩写. 始终使用 .py 作为文件后缀名,不要用破折号.</p><p>应该避免的名称</p><ul><li>单字符名称, 除了计数器和迭代器,作为 try/except 中异常声明的 e,作为 with 语句中文件句柄的 f.</li><li>包/模块名中的连字符(-)</li><li>双下划线开头并结尾的名称(Python保留, 例如__init__)</li></ul><h3 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h3><p>即使是一个打算被用作脚本的文件, 也应该是可导入的. 并且简单的导入不应该导致这个脚本的主功能(main functionality)被执行, 这是一种副作用. 主功能应该放在一个main()函数中.</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="函数长度"><a href="#函数长度" class="headerlink" title="函数长度"></a>函数长度</h3><p>推荐函数功能尽量集中,简单,小巧</p><p>不对函数长度做硬性限制.但是若一个函数超过来40行,推荐考虑一下是否可以在不损害程序结构的情况下对其进行分解. </p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux实用工具</title>
      <link href="/2022/12/07/linux-shi-yong-gong-ju/"/>
      <url>/2022/12/07/linux-shi-yong-gong-ju/</url>
      
        <content type="html"><![CDATA[<h3 id="截图工具"><a href="#截图工具" class="headerlink" title="截图工具"></a>截图工具</h3><p>最好用的当属Kazan和Shutter，前者不仅能截屏还能录屏；后者截屏功能相对更加强大。<br>命令行apt安装即可。</p><h3 id="办公软件"><a href="#办公软件" class="headerlink" title="办公软件"></a>办公软件</h3><p>WPS，支持国产</p><h3 id="远程控制"><a href="#远程控制" class="headerlink" title="远程控制"></a>远程控制</h3><p>用过Google chrome desktop, Teamviewer等一大堆软件，现在表示还是向日(Sunlogin)最好用…</p><h3 id="c-编译软件"><a href="#c-编译软件" class="headerlink" title="c++编译软件"></a>c++编译软件</h3><p>有很多，推荐一款常用的 Bazel</p><h3 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h3><p>用来用去，最好的还是VSCode。此外你也可以尝试Atom</p>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有价值的网站</title>
      <link href="/2022/12/07/you-jie-zhi-de-wang-zhan/"/>
      <url>/2022/12/07/you-jie-zhi-de-wang-zhan/</url>
      
        <content type="html"><![CDATA[<p>本文分为两部分，前半部分主要涉及计算机编程，后半部分涉及机器人学。无论你是想转码的小白，初学的开发者，还是机器人工程师，希望这篇文章都能给你带来新的知识。</p><h2 id="一些CS网站分享"><a href="#一些CS网站分享" class="headerlink" title="一些CS网站分享"></a>一些CS网站分享</h2><h3 id="Google开源项目风格指南-中文版"><a href="#Google开源项目风格指南-中文版" class="headerlink" title="Google开源项目风格指南 (中文版)"></a><a href="https://zh-google-styleguide.readthedocs.io/en/latest/contents/">Google开源项目风格指南</a> (中文版)</h3><p>养成一套良好的代码编写习惯非常重要，无论是对于开发者还是阅读者 <span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><h3 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a><a href="https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/markdown-basics">Markdown</a></h3><p>Markdown写作是制作blog/github的好伙伴。</p><h3 id="about-Mermaid"><a href="#about-Mermaid" class="headerlink" title="about Mermaid"></a><a href="https://mermaid-js.github.io/mermaid/#/README">about Mermaid</a></h3><p>Mermaid用来在Markdown中画图，比如甘特图、流程图等，很好的辅助工具。</p><h3 id="CS自学指南"><a href="#CS自学指南" class="headerlink" title="CS自学指南"></a><a href="https://csdiy.wiki/">CS自学指南</a></h3><p>该作者总结了很多自学cs的方法，有用网课和网站</p><h3 id="CS106L-Standard-C-Programming"><a href="#CS106L-Standard-C-Programming" class="headerlink" title="CS106L: Standard C++ Programming"></a><a href="http://web.stanford.edu/class/cs106l/">CS106L: Standard C++ Programming</a></h3><p>c++的进阶课程，适合有一点编程基础的人学习，能够了解c++更多语法和特性。</p><h3 id="编写高质量代码改善-Python-程序的-91-个建议"><a href="#编写高质量代码改善-Python-程序的-91-个建议" class="headerlink" title="编写高质量代码改善 Python 程序的 91 个建议"></a><a href="https://l1nwatch.gitbook.io/writing_solid_python_code_gitbook/">编写高质量代码改善 Python 程序的 91 个建议</a></h3><p>让你的Python代更专业！</p><h3 id="c-primer-plus习题及笔记"><a href="#c-primer-plus习题及笔记" class="headerlink" title="c++ primer plus习题及笔记"></a><a href="https://github.com/ShujiaHuang/Cpp-Primer-Plus-6th">c++ primer plus习题及笔记</a></h3><h3 id="c-入门教程"><a href="#c-入门教程" class="headerlink" title="c++入门教程"></a><a href="http://c.biancheng.net/cplus/">c++入门教程</a></h3><p>类似菜鸟教程，但是我觉得写的比菜鸟更详细一点，可以当做cheatsheet查阅c++语法。</p><h2 id="一些机器人学网站分享"><a href="#一些机器人学网站分享" class="headerlink" title="一些机器人学网站分享"></a>一些机器人学网站分享</h2><h3 id="机器人工程师成长指南"><a href="#机器人工程师成长指南" class="headerlink" title="机器人工程师成长指南"></a><a href="https://zhuanlan.zhihu.com/p/22266788">机器人工程师成长指南</a></h3><p>教你如何从小白一步步成为优秀的机器人领域开发者</p>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科学上网（2022年12月） 适用于Linux &amp; Windows</title>
      <link href="/2022/12/05/ru-he-ke-xue-shang-wang/"/>
      <url>/2022/12/05/ru-he-ke-xue-shang-wang/</url>
      
        <content type="html"><![CDATA[<p>作为机器人工程师，我们不得不使用stackoverflow，github等网站。</p><p>由于众所周知的原因，我们需要科学上网工具，在此推荐一款便宜好用的梯子，适用于全平台:<br><a href="https://windscribe.com/">Windscribe</a><br>它不仅节点多，速度快，而且便宜。支持按照节点数购买，一个地区的节点一个月仅需一刀。</p><p>如果你的电脑不能打开windscibe官网，可以在<a href="https://github.com/rd-zhang/windscribe_deb">这里</a>下载deb安装包。</p>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《编写可读代码的艺术》(一)</title>
      <link href="/2022/12/02/bian-xie-ke-du-dai-ma-de-yi-zhu-1/"/>
      <url>/2022/12/02/bian-xie-ke-du-dai-ma-de-yi-zhu-1/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>第一次被推荐这本书的时候我已经写了两年代码。尽管自己已经形成了一套命名和注释方法，但是对于代码的可阅读性并没有太过深入的思考。_<a href="https://mcusoft.files.wordpress.com/2015/04/the-art-of-readable-code.pdf">The Art of Readable Code</a>_ (中文译名<a href="https://awesome-programming-books.github.io/clean-code/%E7%BC%96%E5%86%99%E5%8F%AF%E8%AF%BB%E4%BB%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF.pdf">《编写可读代码的艺术》</a>)通过15个章节从简到繁，轻松又愉快的使你明白如何写出‘易于理解’的代码。</p><h3 id="第1章—代码应当易于理解"><a href="#第1章—代码应当易于理解" class="headerlink" title="第1章—代码应当易于理解"></a>第1章—代码应当易于理解</h3><p><strong>代码易于理解</strong> 是关键思想。<br>代码的写法应当使别人理解它所需的时间最小化。但是虽然减少代码行数是一个重要目标，我们的最终目标仍然是把理解代码所需时间最小化。<br>编写代码时要经常站在别的角度，想一想自己写的代码别能否轻松理解。</p><h1 id="Part-1-表明层次的改进"><a href="#Part-1-表明层次的改进" class="headerlink" title="Part 1. 表明层次的改进"></a>Part 1. 表明层次的改进</h1><p>可读性之旅从“表面层次”的改进开始：选择好的名字、写好的注释以及把代码整洁的写成更好的格式。</p><h3 id="第2章—把信息装进名字里"><a href="#第2章—把信息装进名字里" class="headerlink" title="第2章—把信息装进名字里"></a>第2章—把信息装进名字里</h3><p>选择专业的词语：比如fetchPage相比getPage显得更加专业而清晰；<br>避免泛泛的名字: 如tmp，retval。好的名字应当描述变量的目的或者它承载的值，除非你确定你只是临时的用一次tmp;<br>使用具体的名字更细致的描述：<a href="https://blog.csdn.net/fuhanghang/article/details/119805459">这里</a>总结了一些常用的命名方法。个人偏爱使用下划线法命名，把每个变量具体干什么使用起英文短语命名，如 <em>log_finishedinfo_when_reach_terminal</em> ;<br>给变量名加上重要细节：比如JS中的 <em>getTime()</em> 返回单位是毫秒，那么就可以给变量加上 _<em>ms</em> 的后缀;<br>名字的长度：应当遵循作用域越大名字越长的原则，比如一个字母 <em>m</em> 如果作用于全域，读者很可能不知道他是干什么的。这就好比旅行，越长的假期你总是会带越多的行李；<br>有目的使用下划线：你可以在类成员和局部变量后面加上下划线来区分他们。</p><h3 id="第3章—不会误解的名字"><a href="#第3章—不会误解的名字" class="headerlink" title="第3章—不会误解的名字"></a>第3章—不会误解的名字</h3><p><em>Filter()</em> 是一个很好的例子，我的意思是它是一个很糟糕的命名。因为读者根本不知道这个函数是用于 <strong>筛选出</strong> 一部分结果还是 <strong>筛选掉</strong> 一部分结果！<br>而涉及到bool值的时候尽量避免诸如多重否定的文字游戏。比如 <em>is_task_finished</em> 的返回值能够直观的说明任务是否完成了。<br>对于区间的表示，推荐使用一套约定俗成的方法：</p><ul><li>min, max 表示极限</li><li>first, last 表示包含的范围(闭区间)</li><li>begin, end 表示包含的范围(开区间)</li><li>etc…</li></ul><p>总之，你应该三思，别人是否会对命名产生不一样的理解。</p><h3 id="第4章—审美"><a href="#第4章—审美" class="headerlink" title="第4章—审美"></a>第4章—审美</h3><p>好的代码应该看上去遵循 <strong>养眼</strong> ，三条原则：</p><ul><li>使用一致的布局，让读者很快就能习惯这种风格</li><li>让相似的代码看上去相似</li><li>把相关的代码分组，形成代码块</li></ul><p>编程的大部分时间都花在看代码上，浏览代码的速度越快，人们越容易使用它：</p><ul><li>重新安排换行来保持一致和紧凑；</li><li>用方法来整理不规则的东西；</li><li>在需要的时候使用列对齐；</li><li>选择一个有意义的顺序，比如重要性排序，并保持一致的使用它；</li><li>把声明按照块组织起来，按照逻辑分组，添加注释；</li><li>把代码分成段落，比如按照步骤划分；</li><li>个人风格要保证一致性，比如大括号的位置。</li></ul><h3 id="第5章—该写什么样的注释"><a href="#第5章—该写什么样的注释" class="headerlink" title="第5章—该写什么样的注释"></a>第5章—该写什么样的注释</h3><p> 注释的目的是尽量帮助读者了解得和作者一样多：</p><ul><li>不要为那些从代码本身就能快速推断的事实写注释</li><li>不要为了注释而注释</li><li>与其给名字不好的函数写注释，不如把其名字先改好，即 <strong>好代码 &gt; 坏代码 + 好注释</strong></li></ul><p> 应该记录下来的想法包括：</p><ul><li>为什么这个地方代码写成这样而不是别的？</li><li>代码中有缺陷的地方，可以写一个 _TODO: XXX_；</li><li>常量为什么定义这个值？ (比如 <em>length = 10 is big enough to describe the object shape</em> )。</li></ul><p>站在读者的立场上思考：</p><ul><li>预料到那些地方会使读者不解或出乎意料，并加上注释；</li><li>在文件/类的级别上使用“全局观”注释，以解释他们是如何一起工作的</li><li>用注释作为代码块的总结。</li></ul><h3 id="第6章—写出言简意赅的注释"><a href="#第6章—写出言简意赅的注释" class="headerlink" title="第6章—写出言简意赅的注释"></a>第6章—写出言简意赅的注释</h3><p> <strong>注释要有很高的信息率和空间率</strong></p><ul><li>让注释保持紧凑，能写一行的注释不要写三行；</li><li>避免使用不明确的代词，不要用 <em>it</em> 这种模糊词语；</li><li>润色粗糙的句子(这可能考验语文功底…)；</li><li>精确描述函数的行为；</li><li>用输入输出例子来描述特殊的情况(对于工程师来说这无疑更直观)；</li><li>声明代码的意图；</li><li>使用具名函数。python 等语言能这么调用： <em>connect(timeout = 10, use_encryption = False)</em> ；</li><li>采用信息量高的词语；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《编写可读代码的艺术》(二)</title>
      <link href="/2022/12/02/bian-xie-ke-du-dai-ma-de-yi-zhu-2/"/>
      <url>/2022/12/02/bian-xie-ke-du-dai-ma-de-yi-zhu-2/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>第一次被推荐这本书的时候我已经写了两年代码。尽管自己已经形成了一套命名和注释方法，但是对于代码的可阅读性并没有太过深入的思考。_<a href="https://mcusoft.files.wordpress.com/2015/04/the-art-of-readable-code.pdf">The Art of Readable Code</a>_ (中文译名<a href="https://awesome-programming-books.github.io/clean-code/%E7%BC%96%E5%86%99%E5%8F%AF%E8%AF%BB%E4%BB%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF.pdf">《编写可读代码的艺术》</a>)通过15个章节从简到繁，轻松又愉快的使你明白如何写出‘易于理解’的代码。</p><h1 id="Part-2-简化循环和逻辑"><a href="#Part-2-简化循环和逻辑" class="headerlink" title="Part 2. 简化循环和逻辑"></a>Part 2. 简化循环和逻辑</h1><p>这一部分将深入讨论程序的“循环和逻辑”：控制流、逻辑表达式等等。我们将试着最小化代码中的“思维包袱”来达到目的。</p><h3 id="第7章—把控制流变得易读"><a href="#第7章—把控制流变得易读" class="headerlink" title="第7章—把控制流变得易读"></a>第7章—把控制流变得易读</h3><p>条件语句中左右两侧分别是“被询问的”和“用来作比较的标准”，比如 <em>if(length &gt; 10)</em> 看起来就很自然；<br><em>if/else</em> 语句处理顺序：正常逻辑优先，简单逻辑优先，可疑或有趣项优先；<br>对于C语言中的三目表达式，更重要的是减少理解其逻辑的时间，因此要注意代码行数与复杂度之间的平衡；<br>避免 <em>do/while</em> 循环，尽量换成 <em>while</em> 或其他循环；<br>可以在函数中提前 <em>return</em> 返回，但要避免使用臭名昭著的 <em>goto</em> ；<br><strong>最小化嵌套</strong> “故意嵌套很深的代码就是一坨屎” ——图图。你可以通过提前返回来减少嵌套。</p><h3 id="第8章—拆分超长的表达式"><a href="#第8章—拆分超长的表达式" class="headerlink" title="第8章—拆分超长的表达式"></a>第8章—拆分超长的表达式</h3><p>如果你百度一下，可能会发现人脑的容量高达7亿TB。但是其实人脑的RAM非常小，以至于大脑同时只能考虑3~4件事。本章的核心思想是—— <strong>把超长的表达式拆分成更容易理解的小块</strong> 。<br>一个简单的例子件事，把某一行代码拆分为两行。第一行多定义一个变量，即“解释变量”，他能够帮助读者理解这个值是干什么的；<br>你也可以使用一个总结性的变量，比如一个bool值，来解释一些拗口的判断式，并利用 <em>if/else</em> 辅助；<br>使用电路学中的“德摩根定理”，它的核心思想是通过整体取反的方式，在不改变逻辑的情况下使判断式更好理解(即前文提到的避免多重否定)；<br>不要滥用短路逻辑；<br>提取出大量重复的表达式为变量，例如C++中的宏(尽管有时并不建议使用宏，但当它对可读性利大于弊时可以采用)。</p><h3 id="第9章—变量与可读性"><a href="#第9章—变量与可读性" class="headerlink" title="第9章—变量与可读性"></a>第9章—变量与可读性</h3><p>对于变量的草率运用会让程序更难理解：</p><ul><li>变量越多，越难以跟踪他们的动向；</li><li>变量的作用域越大，就需要跟踪它的动向越久；</li><li>变量改变地越频繁，就越难以跟踪它的当前值。</li></ul><p>如何处理：</p><ul><li>减少无价值的临时变量，比如根本就没有必要定义 <em>now = datetime.datetime.now()</em> ，直接使用这个时间函数即可；</li><li>减少控制流变量，避免使用 <em>done</em> 这样的“控制流变量”；</li><li>缩小变量作用域，防止名称污染，让你的变量对尽量少的代码行可见；</li><li>只写一次的变量更好，因为常量往往不会引来麻烦。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《编写可读代码的艺术》(三)</title>
      <link href="/2022/12/02/bian-xie-ke-du-dai-ma-de-yi-zhu-3/"/>
      <url>/2022/12/02/bian-xie-ke-du-dai-ma-de-yi-zhu-3/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>第一次被推荐这本书的时候我已经写了两年代码。尽管自己已经形成了一套命名和注释方法，但是对于代码的可阅读性并没有太过深入的思考。_<a href="https://mcusoft.files.wordpress.com/2015/04/the-art-of-readable-code.pdf">The Art of Readable Code</a>_ (中文译名<a href="https://awesome-programming-books.github.io/clean-code/%E7%BC%96%E5%86%99%E5%8F%AF%E8%AF%BB%E4%BB%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF.pdf">《编写可读代码的艺术》</a>)通过15个章节从简到繁，轻松又愉快的使你明白如何写出‘易于理解’的代码。</p><h1 id="Part-3-重新组织代码"><a href="#Part-3-重新组织代码" class="headerlink" title="Part 3. 重新组织代码"></a>Part 3. 重新组织代码</h1><p>该部分会讨论可以在函数级别对代码做更大的改动。</p><h3 id="第10章—抽取不相关的子问题"><a href="#第10章—抽取不相关的子问题" class="headerlink" title="第10章—抽取不相关的子问题"></a>第10章—抽取不相关的子问题</h3><p><strong>积极地发现并抽取出不相关的子逻辑</strong></p><ul><li>如果足够多行数的代码并不是在解决当前问题，那么把他们放到独立的函数中去；</li><li>你可以自己写一些工具性的代码来填充编程语言中的空白，比如C++中没有简单的方法来读取整个文件，你可以自己写一个 <em>ReadFileToString()</em> 并当做库函数使用；</li><li>创建大量通用代码，这样你代码的其余部分会更小而且容易思考；</li><li>简化已有接口，按需重塑接口；</li><li>最后要记住，避免 <strong>过犹不及</strong> ！</li></ul><h3 id="第11章—一次只做一件事"><a href="#第11章—一次只做一件事" class="headerlink" title="第11章—一次只做一件事"></a>第11章—一次只做一件事</h3><p>把代码组织得一次只做一件事：</p><ul><li>列出代码所做的所有任务，其中一些可以变成独立的函数/类；</li><li>尽力把这些任务拆分到不同的函数中。</li></ul><h3 id="第12章—把想法变成代码"><a href="#第12章—把想法变成代码" class="headerlink" title="第12章—把想法变成代码"></a>第12章—把想法变成代码</h3><p>用自然语言描述程序来帮助写出更自然的代码:</p><ul><li>清楚地描述逻辑；</li><li>了解所使用的编程语言的库函数，比如一些提示框内的建议很有帮助；</li><li>首先把本方法用于小块代码，然后应用于更大的问题。</li></ul><h3 id="第13章—少写代码"><a href="#第13章—少写代码" class="headerlink" title="第13章—少写代码"></a>第13章—少写代码</h3><p><strong>最好读的代码就是没有代码</strong></p><ul><li>别费劲去做你不太需要的功能；</li><li>质疑并拆分你的需求；</li><li>记得思考你的输入和输出是什么，并不是任何时候输入都是很复杂的；</li><li>让你的代码库越小、越轻量级越好；</li><li>熟悉你周边的库，避免重复造轮子。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《编写可读代码的艺术》(四|实战)(完)</title>
      <link href="/2022/12/02/bian-xie-ke-du-dai-ma-de-yi-zhu-4/"/>
      <url>/2022/12/02/bian-xie-ke-du-dai-ma-de-yi-zhu-4/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>第一次被推荐这本书的时候我已经写了两年代码。尽管自己已经形成了一套命名和注释方法，但是对于代码的可阅读性并没有太过深入的思考。_<a href="https://mcusoft.files.wordpress.com/2015/04/the-art-of-readable-code.pdf">The Art of Readable Code</a>_ (中文译名<a href="https://awesome-programming-books.github.io/clean-code/%E7%BC%96%E5%86%99%E5%8F%AF%E8%AF%BB%E4%BB%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF.pdf">《编写可读代码的艺术》</a>)通过15个章节从简到繁，轻松又愉快的使你明白如何写出‘易于理解’的代码。</p><h1 id="Part-4-精选话题"><a href="#Part-4-精选话题" class="headerlink" title="Part 4. 精选话题"></a>Part 4. 精选话题</h1><p>在本书的最后一部分，之前讨论的各种技巧会应用到两个精选的话题中。</p><h3 id="第14章—测试与可读性"><a href="#第14章—测试与可读性" class="headerlink" title="第14章—测试与可读性"></a>第14章—测试与可读性</h3><p><strong>测试应当具有可读性，以便使其他程序员可以舒服的改变或者增加测试</strong><br>记住对使用者隐去不重要的细节，以便更重要的细节会更为突出；<br>大多数的测试都能精炼成“对于xx的输入/情况，期望有xx的输出/行为”；<br><strong>让错误消息具有可读性</strong><br>多用 <em>assert()</em>;<br>手工打造错误消息，选择好的测试输入，又简单又能完成工作的测试值更好；<br>与其建立单个“完美”输入来完整地执行代码，不如写多个小测试，因为他们更具有可读性；<br>为测试函数命名，但是避免“test”这种没什么意义的名字；</p><p>下面我们来看一个例子，在这段代码中</p><pre class=" language-c++"><code class="language-c++">void Test1(){  vector<ScoredDocument> docs;  docs.resize(5);  docs[0].url = "http://example.com"  docs[0].score = -5.0;  docs[1].url = "http://example.com"  docs[1].score = 1;  docs[2].url = "http://example.com"  docs[2].score = 4;  docs[3].url = "http://example.com"  docs[3].score = -99998.7;  docs[4].url = "http://example.com"  docs[4].score = 3.0;  SortAndFileterDocs(&Docs);  assert(docs.size() == 3);  assert(docs[0].score == 4);  assert(docs[1].score == 3.0);  assert(docs[2].score == 1);}</code></pre><p>这段测试代码至少犯了8条错误：</p><ul><li>测试太长，充满不重要的细节</li><li>增加新测试将很不容易</li><li>测试失败的消息不是很有帮助。如果测试失败，它仅仅是“Assertion failed:docs.size() == 3”，对于调试没有什么帮助</li><li>这段测试代码想同时测完所有东西。拆分为多个测试会更具可读性</li><li>测试的输入不是很简单，尤其是“-99998.7”这种夸张的数值</li><li>它没有其他测试其他极端输入，比如空输入向量，很长的向量等</li><li>函数名字没有什么实意</li></ul><p>存在一种对测试较好的开发方式，即大名鼎鼎的测试驱动开发(TDD)。其支持者相信这种流程对没有测试的代码来将会做出极大的质量改进。无论你选择那种驱动开发方式，至少通过在写代码时候想着测试这件事能够帮助我们把代码写的更好。</p><h3 id="第15章—设计并改进“分钟-x2F-小时计数器”"><a href="#第15章—设计并改进“分钟-x2F-小时计数器”" class="headerlink" title="第15章—设计并改进“分钟/小时计数器”"></a>第15章—设计并改进“分钟/小时计数器”</h3><p>见 <a href="https://awesome-programming-books.github.io/clean-code/%E7%BC%96%E5%86%99%E5%8F%AF%E8%AF%BB%E4%BB%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF.pdf">编写可读代码的艺术</a> 第十五章</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++实用的库</title>
      <link href="/2022/12/01/c-you-yong-de-ku/"/>
      <url>/2022/12/01/c-you-yong-de-ku/</url>
      
        <content type="html"><![CDATA[<p>c++和Python不同，后者有pip这样的工具来管理模组。c++很多库需要自己下载源码编译。本文旨在分享那些实用的库的安装使用方法</p><h3 id="Boost库"><a href="#Boost库" class="headerlink" title="Boost库"></a>Boost库</h3><p>一定首先安装Boos库，他是很多其他库的基石</p><pre><code>sudo apt-get install mpi-default-dev　sudo apt-get install libicu-dev　   sudo apt-get install python-dev　sudo apt-get install libbz2-dev　</code></pre><p>boost库源文件下载 <a href="https://sourceforge.net/projects/boost/">https://sourceforge.net/projects/boost/</a><br>解压后进入文件夹执行</p><pre><code>./bootstrap.shsudo ./b2sudo ./b2 install</code></pre><p><strong>这个过程可能很久..</strong><br><a href="https://www.cnblogs.com/nanmi/p/15161211.html">安装Boost库</a></p><h3 id="NumCPP"><a href="#NumCPP" class="headerlink" title="NumCPP"></a>NumCPP</h3><p>熟悉Python的人一定用过NumPy，同理c++也有这样的库。<br><a href="https://www.cnblogs.com/nanmi/p/15161211.html">安装NumCPP库</a></p><h3 id="openCV"><a href="#openCV" class="headerlink" title="openCV"></a>openCV</h3><p>去github下载源码然后build<br><a href="https://www.geeksforgeeks.org/how-to-install-opencv-in-c-on-linux/">ref</a></p>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++编译那些事儿</title>
      <link href="/2022/12/01/c-bian-yi-na-xie-shi/"/>
      <url>/2022/12/01/c-bian-yi-na-xie-shi/</url>
      
        <content type="html"><![CDATA[<p>我首先深入学习了Python，然后才是c++。尽管本科一年级学过c语言，但是在visual studio里面的一件编译运行和在Linux下手动编译很不一样。</p><h2 id="为什么要编译"><a href="#为什么要编译" class="headerlink" title="为什么要编译"></a>为什么要编译</h2><p>说白了就是把高级语言翻译成汇编语言、机器码这种计算机能够理解的语言。Python相当于边编译边运行，而c++先编译完再运行，后者自然速度起飞。</p><h2 id="编译工具"><a href="#编译工具" class="headerlink" title="编译工具"></a>编译工具</h2><p>长话短说，对于Linux下的cpp文件，我们可以使用免费开源的g++，比如<code>g++ main.cpp -o demo</code> 是把main.cpp编译并生成名为demo的可执行文件。</p><p>g++是GCC中的GUN C++ Compiler。当程序只有一个源文件时，直接就可以用gcc/g++命令编译。但是当程序包含很多个源文件时，这是一件很头疼的事情！</p><p>所以出现了make工具！make工具可以看成是一个智能的批处理工具，它本身并没有编译和链接的功能，而是用类似于批处理的方式—通过调用makefile文件中用户指定的命令来进行编译和链接的。</p><p>makefile是什么？简单的说就像一首歌的乐谱，make工具就像指挥家，指挥家根据乐谱指挥整个乐团怎么样演奏，make工具就根据makefile中的命令进行编译和链接的。makefile命令中就包含了调用g++（也可以是别的编译器）去编译某个源文件的命令。</p><h3 id="make-vs-Cmake"><a href="#make-vs-Cmake" class="headerlink" title="make vs Cmake"></a>make vs Cmake</h3><p>makefile在一些简单的工程完全可以人工手下，但是当工程非常大的时候，手写makefile也是非常麻烦的，如果换了个平台makefile又要重新修改。</p><p>这时候就出现了Cmake这个工具，cmake就可以更加简单的生成makefile文件给上面那个make用。当然cmake还有其他功能，就是可以跨平台生成对应平台能用的makefile，你不用再自己去修改了。</p><p>可是cmake根据什么生成makefile呢？它又要根据一个叫CMakeLists.txt文件去生成makefile。</p><h3 id="Cmake-vs-Bazel"><a href="#Cmake-vs-Bazel" class="headerlink" title="Cmake vs Bazel"></a>Cmake vs Bazel</h3><p>Bazel是Google开源的编译构建工具，以Monolithic Repository为理念。与makefile &amp; CMake不同，Bazel另起炉灶，采用client/server运行模式，为云编译而生。Bazel工具将编译过程分三个阶段：Load Phase/Analysis Phase/Execution phase。研发人员实现workspace/build/.bzl三种文件，Bazel执行这些文件生成action graph，执行action来构建项目。</p><h2 id="怎么选择编译工具？"><a href="#怎么选择编译工具？" class="headerlink" title="怎么选择编译工具？"></a>怎么选择编译工具？</h2><p>因为Bazel采用了类似Python的语法，所以其学习曲线相比CMake要平缓一些。Bazel对thirdparty支持还是非常友好的。</p><p>综合考虑时，CMake是一个尽管保守但仍旧不错的选择。我个人建议，如果你的团队在用Bazel，则可以尝试Bazel。否则仍然推荐先使用Cmake。</p><p><a href="https://blog.csdn.net/hblhly/article/details/80740493">ref1</a><br><a href="https://zhuanlan.zhihu.com/p/112712537">ref2</a><br><a href="https://www.jianshu.com/p/d01472734a78">ref3</a></p>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变得更强</title>
      <link href="/2022/12/01/bian-de-geng-qiang/"/>
      <url>/2022/12/01/bian-de-geng-qiang/</url>
      
        <content type="html"><![CDATA[<h3 id="漫画资本论"><a href="#漫画资本论" class="headerlink" title="漫画资本论"></a>漫画资本论</h3><p>一本轻松有趣的资本论入门漫画书，主要讲述的是资本论三卷中第一卷内容，让你对全书有一个大致了解。适合零基础的同志学习。<br><a href="https://www.bilibili.com/read/cv10516935/">漫画资本论(上)</a>  <a href="https://www.bilibili.com/read/cv10517038/">漫画资本论(下)</a></p><h3 id="21世纪资本论"><a href="#21世纪资本论" class="headerlink" title="21世纪资本论"></a>21世纪资本论</h3><p>写于2014年，里面列举了很多中国和印度的例子，很有意思。</p>]]></content>
      
      
      <categories>
          
          <category> 变得更强 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 变得更强 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
